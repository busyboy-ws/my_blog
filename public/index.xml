<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小松松的个人博客，记录学习和生活的点点滴滴！</title>
    <link>/</link>
    <description>Recent content on 小松松的个人博客，记录学习和生活的点点滴滴！</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>小松松</copyright>
    <lastBuildDate>Tue, 20 Aug 2019 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>一起来刷leetcode吧</title>
      <link>/post/leetcode/</link>
      <pubDate>Thu, 09 Apr 2020 16:01:23 +0800</pubDate>
      
      <guid>/post/leetcode/</guid>
      
        <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;对于技术人来说，&lt;strong&gt;算法&lt;/strong&gt;,&lt;strong&gt;数据结构&lt;/strong&gt;是和别人区分开的一个实质性体现，闲来无事的时候刷一刷,增加自己的技能是非常必要的.&lt;/p&gt;
&lt;p&gt;欢迎&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;关注&lt;/code&gt;，一起刷题，一起成长.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leetcode地址： &lt;a href=&#34;https://leetcode-cn.com/u/xiaonsongsong/&#34;&gt;https://leetcode-cn.com/u/xiaonsongsong/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github地址： &lt;a href=&#34;https://github.com/busyboy-ws/c_code&#34;&gt;https://github.com/busyboy-ws/c_code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Tue, 20 Aug 2019 21:38:52 +0800</pubDate>
      
      <guid>/about/</guid>
      
        <description>&lt;p&gt;暂无&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>k8s集群上部署kafka集群</title>
      <link>/post/kafka-deploy-on-k8s/</link>
      <pubDate>Thu, 30 Apr 2020 16:01:23 +0800</pubDate>
      
      <guid>/post/kafka-deploy-on-k8s/</guid>
      
        <description>&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;
&lt;p&gt;公司需要一套kafka集群来采集各个区域的用户行为日志,目前香港集群已经部署完成,还需要在东南亚和北美各创建一个kafka集群并将数据同步到香港的kafka集群中. kafak的集群部署在kubernets中,采用helm部署方式,集群之间的数据同步使用的是kafka官方给的解决方案&lt;strong&gt;mirrormaker&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;安装kafka集群&#34;&gt;安装kafka集群&lt;/h4&gt;
&lt;p&gt;kafka集群的安装已经收纳到helm官网,首先我们要添加一个&lt;code&gt;incubator&lt;/code&gt;的仓库地址，因为 stable 的仓库里面并没有合适的 Kafka 的 Chart 包：&lt;/p&gt;
&lt;p&gt;helm官方kafak地址如下: &lt;a href=&#34;https://github.com/helm/charts/tree/master/incubator/kafka&#34;&gt;https://github.com/helm/charts/tree/master/incubator/kafka&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/
$ helm repo update
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &amp;quot;incubator&amp;quot; chart repository
...Successfully got an update from the &amp;quot;stable&amp;quot; chart repository
Update Complete. ⎈ Happy Helming!⎈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用helm安装就非常的简单了,比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install --name my-kafka incubator/kafka
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然默认的安装不适合我们实际的需求,我们需要编写自己的&lt;strong&gt;values.yaml&lt;/strong&gt;文件.kafka的后端需要存储空间,阿里云本省也提供了很多可以使用的存储插件,我们这里使用的是NAS,由于需要做&lt;strong&gt;mirrormaker&lt;/strong&gt;,我们需要将kafka集群暴露在公网.最后使用的&lt;strong&gt;values.yaml&lt;/strong&gt;文件如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;external:
  enabled: true
  type: LoadBalancer
  distinct: true
  dommain: bnstat.com

configurationOverrides:
  &amp;quot;advertised.listeners&amp;quot;: |-
    EXTERNAL://kafka-$((${KAFKA_BROKER_ID})).example.com:19092
  &amp;quot;listener.security.protocol.map&amp;quot;: |-
    PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT

persistence:
  size: &amp;quot;10Gi&amp;quot;
  storageClass: alicloud-nas
livenessProbe:
  initialDelaySeconds: 120
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里说一下我遇到的问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;kafka默认会为我们在底层的云环境创建三个LB,但这些都是内网的(阿里云中).一开始我认为在LB中绑定对应的外网IP不就可以把服务暴露出来了,但事情并没有这么简单. 这是由于kafak中的配置文件两个字段所定义的&lt;strong&gt;listeners&lt;/strong&gt;,&lt;strong&gt;advertised.listeners&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;listeners: 一般用于内网通信,如果不准备把kafka暴露在公网只需要配置这个参数&lt;/li&gt;
&lt;li&gt;advertised.listeners: 用于配置外网,会将此地址配置在zookeeper中(这里有一个坑)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这两个字段可以参考文档:&lt;a href=&#34;https://segmentfault.com/a/1190000020715650&#34;&gt;https://segmentfault.com/a/1190000020715650&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在使用helm部署时,我对&lt;strong&gt;values.yaml&lt;/strong&gt;的更改一直使用的是&lt;strong&gt;helm upgrade&lt;/strong&gt;的方式,但当你修改pod中的环境变量内容时并不会触发pod更新,你需要手动更新. 而且由于&lt;strong&gt;advertised.listeners&lt;/strong&gt;会向zookeeper中写入,修改&lt;strong&gt;value.yaml&lt;/strong&gt;并不会更改zookeeper中的&lt;strong&gt;advertised.listeners&lt;/strong&gt;数据,这一度困扰了我很久.&lt;/p&gt;
&lt;p&gt;在使用&lt;strong&gt;external&lt;/strong&gt;字段时,建议在配置的&lt;strong&gt;advertised.listeners&lt;/strong&gt;采用域名的方式,即使kafka对外的LB发生改变也只需要改解析就可以了,对于业务没有影响.&lt;/p&gt;
&lt;p&gt;最后: helm安装时直接指定&lt;strong&gt;values.yaml&lt;/strong&gt;文件既可以.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install my-kafka -f values.yaml incubator/kafka
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过内部连接kafak集群就非常简单了,使用如下的配置创建一个pod.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: testclient
  namespace: kafka
spec:
  containers:
  - name: kafka
    image: solsson/kafka:0.11.0.0
    command:
      - sh
      - -c
      - &amp;quot;exec tail -f /dev/null&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用如下的配置列出kafka的所有的topic:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kafka exec -ti testclient -- ./bin/kafka-topics.sh --zookeeper my-release-zookeeper:2181 --list
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;mirrormaker镜像同步&#34;&gt;mirrormaker镜像同步&lt;/h4&gt;
&lt;p&gt;MirrorMaker是Kafka附带的一个用于在Kafka集群之间制作镜像数据的工具。该工具从源集群中消费并生产到目标群集。这种镜像的常见用例是在另一个数据中心提供副本。&lt;/p&gt;
&lt;p&gt;关于mirrormaker制作成Docker镜像的方法网上也有很多,这里我使用的&lt;a href=&#34;https://github.com/srotya/docker-kafka-mirror-maker&#34;&gt;https://github.com/srotya/docker-kafka-mirror-maker&lt;/a&gt;的构建方法,但是由于时间比较长久所以还是自己修改了一部分.修改后的Dockerfile如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM nimmis/java-centos:oracle-8-jre
MAINTAINER Ambud Sharma

ENV WHITELIST *
ENV DESTINATION &amp;quot;localhost:6667&amp;quot;
ENV SOURCE &amp;quot;localhost:6667&amp;quot;
ENV SECURITY &amp;quot;PLAINTEXT&amp;quot;
ENV GROUPID &amp;quot;_mirror_maker&amp;quot;
ENV PRINCIPAL &amp;quot;kafka/localhost@EXAMPLE.COM&amp;quot;
ENV KEYTAB_FILENAME &amp;quot;mirror.keytab&amp;quot;

RUN mkdir -p /usr/local/kafka_2.12-2.0.1
COPY kafka_2.12-2.0.1 /usr/local/kafka_2.12-2.0.1
RUN yum -y install gettext
RUN mkdir -p /etc/mirror-maker/
RUN mkdir /etc/security/keytabs/
ADD ./consumer.config /tmp/mirror-maker/
ADD ./producer.config /tmp/mirror-maker/
ADD ./kafka_jaas.conf /tmp/mirror-maker/
ADD ./run.sh /etc/mirror-maker/
RUN chmod +x /etc/mirror-maker/run.sh

CMD /etc/mirror-maker/run.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此镜像已经上传到Dockerhub中,地址:&lt;a href=&#34;https://hub.docker.com/r/uxiaosongsong/mirror-maker&#34;&gt;https://hub.docker.com/r/uxiaosongsong/mirror-maker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上的坏境变量也非常的简单,简单介绍一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WHITELIST&lt;/strong&gt;: 要镜像同步的topic,支持正则表达式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DESTINATION&lt;/strong&gt;: 要同步的目表kafka集群地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOURCE&lt;/strong&gt;: 提供同步kafka集群的数据的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后再使用一个deploy部署起来就可以了,当然如果你需要同步多个就对应的创建多个deploy就行了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
 name: mirror-maker
 namespace: xxxxx-public
spec:
 replicas: 1
 template:
   metadata:
     labels:
       name: mirror-maker
   spec:
     containers:
     - name: mirror-maker
       image: uxiaosongsong/mirror-maker:v1
       imagePullPolicy: IfNotPresent
       env:
       - name: &amp;quot;WHITELIST&amp;quot;
         value: &amp;quot;ops_test&amp;quot;
       - name: &amp;quot;DESTINATION&amp;quot;
         value: &amp;quot;data-kafka-headless:9092&amp;quot;
       - name: &amp;quot;SOURCE&amp;quot;
         value: &amp;quot;kafka-0.example.com:19092&amp;quot;
     nodeSelector:
       tuiwen-tech.com/phase: data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后便可以在马来集群进行生产数据,硅谷集群消费数据就可以了,如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;马来生产&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;admin@iZ8psdykrxdgcybevaw3wzZ:~$ kubectl -n tuiwen-public exec -ti testclient -- kafka-console-producer --broker-list data-kafka-headless:9092 --topic ops_test
&amp;gt;jijoa
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;硅谷消费&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;➜  kafka git:(master) ✗ kubectl -n tuiwen-public exec -ti testclient -- kafka-console-consumer --bootstrap-server data-kafka:9092 --topic ops_test --from-beginning
jijoa
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;同步延迟验证&#34;&gt;同步延迟验证&lt;/h4&gt;
&lt;p&gt;kafka集群的同步默认走的还是公网,安全性是通过限制ip的访问控制方式来实现的,监测两个集群数据同步的延迟也是一个必要的工作,目前采取的方式为马来生产一个时间数据,硅谷消费掉这个时间数据并和自己生成的时间做差值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生产者代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = &amp;quot;busyboy&amp;quot;
# Date: 4/28/20

import time
from kafka import KafkaProducer


def gen_time():
    current_time = str(round(time.time() * 1000))
    return current_time.encode(&amp;quot;utf8&amp;quot;)

def func():
    i = 0
    while True:
        current_time = gen_time()
        producer = KafkaProducer(bootstrap_servers=[&#39;kafka-2.example.com:19092&#39;,&#39;kafka-1.example.com:19092&#39;,&#39;kafka-0.example.com:19092&#39;])
        future = producer.send(&#39;ops_test&#39;,value=current_time, partition= 0)
        result = future.get(timeout= 10)
        print(result)
        time.sleep(5)


if __name__ == &#39;__main__&#39;:
    func()
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;消费者代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = &amp;quot;busyboy&amp;quot;
# Date: 4/28/20

import time
from kafka import KafkaConsumer


consumer = KafkaConsumer(&#39;ops_test&#39;, bootstrap_servers=[&#39;kafka-2.bnstat.com:19092&#39;,&#39;kafka-1.bnstat.com:19092&#39;,&#39;kafka-0.bnstat.com:19092&#39;])
for msg in consumer:
    print(&#39;time is:%d ms&#39; % (int(round(time.time() * 1000)) - int(msg.value.decode(&amp;quot;utf8&amp;quot;))))

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在消费端消费数据验证延迟.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(.venv) admin@jump-server:~/python$ python kafka-consumer.py
time is:1774 ms
time is:2280 ms
time is:1940 ms
time is:209 ms
time is:210 ms
time is:214 ms
time is:233 ms
time is:211 ms
...
time is:219 ms
time is:214 ms
time is:212 ms
time is:211 ms
time is:469 ms
time is:398 ms
time is:209 ms
time is:209 ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总体来看两端的延迟还是比较理想的在300毫秒以内,后续还可以改造代码将监控的数据放在prometheus中并实施监控起来.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>从socket看事件驱动</title>
      <link>/post/socket-for-ioevent/</link>
      <pubDate>Sat, 11 Apr 2020 16:01:23 +0800</pubDate>
      
      <guid>/post/socket-for-ioevent/</guid>
      
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近一段时间在看werkzegu的源码，也就顺手自己实现了一个类似werkzuge的功能代码，但写完后用&lt;code&gt;ab&lt;/code&gt;压测发现不能支持并发，每个请求都是串行的，这也就引起了我极大的疑惑，顾来写这边文章记录一下. 以下是疑虑的问题所在:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么使用&lt;code&gt;ab&lt;/code&gt;压测&lt;strong&gt;werkzuge&lt;/strong&gt;可以实现并发处理http请求(注：不是真正的并发，只是在请求上)，底层用了什么技术.(io事件驱动)&lt;/li&gt;
&lt;li&gt;io事件驱动和多线程和多进程有什么关系呢？(也考虑过和协程的关系)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;带着这样的问题，我做了以下的代码编写.&lt;/p&gt;
&lt;h2 id=&#34;http服务实现&#34;&gt;Http服务实现&lt;/h2&gt;
&lt;p&gt;我们知道HTTP服务是建立在四层TCP基础之上的,采用的方式为一问一答形式,对应HTTP中的术语为&lt;strong&gt;request&lt;/strong&gt;和&lt;strong&gt;response&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;requests&#34;&gt;requests&lt;/h4&gt;
&lt;p&gt;客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成.
一个典型的使用GET方法来传递数据的实例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;response&#34;&gt;response&lt;/h4&gt;
&lt;p&gt;和客户端请求类型,response也包含四部分: 状态行、消息报头、空行和响应正文。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT

Hello World! My payload includes a trailing CRLF.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;基于以上对HTTP的定义，我们可以使用socket简单实现一个HTTP服务如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import socket,json,time
addr_port = (&#39;127.0.0.1&#39;, 8000)
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind(addr_port)
    s.listen(1)
    print(&amp;quot;listen: http://%s:%s&amp;quot; % addr_port)
    while True:
        conn, addr = s.accept()
        with conn:
            data = conn.recv(1024)
            print(&#39;conn: IP %s, port: %s&#39; % addr)
            print(data);
            if not data: break
            time.sleep(5)
            conn.send(&#39;HTTP/1.1 200 OK\r\n\r\n&#39;.encode())
            conn.sendall(json.dumps({&#39;code&#39;:200,&#39;msg&#39;:&#39;success&#39;}).encode())
    s.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时你可以通过浏览器或者使用&lt;code&gt;curl&lt;/code&gt;命令来作为http客户端发起请求，可以看到服务器响应了一个json格式的数据.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  ~ curl http://127.0.0.1:8000
{&amp;quot;code&amp;quot;: 200, &amp;quot;msg&amp;quot;: &amp;quot;success&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到此可以说我们实现了http协议中定义的最基础的功能:请求和响应. 如果此时你使用如&lt;code&gt;ab&lt;/code&gt;这个样的压测工具你会发现不管有没有指定并发你都会发现请求是串行化的,也就是服务端必须等待上一个请求处理完成后才会接收下一个请求进行处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  ~ ab -c 10 -n 100 http://127.0.0.1:8000/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但对比与werkzuge来说，我们使用同样的压测方法，werkzegu一次可以接收10个并发请求(注意：是接收请求不是处理请求). 你可以这样验证：&lt;/p&gt;
&lt;p&gt;将上面socket代码和werkzuge应用中的处理请求代码&lt;code&gt;sleep 5s&lt;/code&gt;钟,分别使用&lt;code&gt;ab&lt;/code&gt;进行并发10个,共100请求的测试,在5s之后中断&lt;code&gt;ab&lt;/code&gt;测试.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己写的socket： 处理1到2个请求后后端服务由于中断连接就关闭了&lt;/li&gt;
&lt;li&gt;werkzuge: 即使中断了&lt;code&gt;ab&lt;/code&gt;测试了，但对于客户端来说一次并发的请求已经发出，服务端使用了事件驱动的方式也接收了客户端的请求，后续会继续处理请求，可以看到一共处理10请求，也正是客户端的一次并发数.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io事件select&#34;&gt;IO事件select&lt;/h2&gt;
&lt;p&gt;在之前的一篇文章中讲过,werkzuge后端还是调用socketserver中的&lt;code&gt;serve_forever&lt;/code&gt;方法来监听socket. 从源码上可以看出也是使用&lt;code&gt;select&lt;/code&gt;,&lt;code&gt;poll&lt;/code&gt;,&lt;code&gt;epoll&lt;/code&gt;这样io事件模型. 我来详细描述下:&lt;/p&gt;
&lt;p&gt;select, poll, epoll本质上都是同步的I/O，因为它们都是在读写事件就绪后自己负责进行读写，这个读写的过程是阻塞的,所以我们可以看到werkzuge虽然接收了并发的10个请求,但每个处理还是串行的,也就是说响应这些请求的总时间是和我们自定义的单线程是一样的(50s).&lt;/p&gt;
&lt;p&gt;select, poll, epoll 都是一种 I/O 复用的机制。它们都是通过一种机制(其实也就是轮训监听的描述符)来监视多个描述符，一旦某个描述符就绪了，就能通知程序进行相应的读写操作.Python中也提供了对应的模块实现改功能&lt;strong&gt;select&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select&lt;/strong&gt; 模块实现了上述的三个I/O复用机制,我们来看一下select定义.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def select(rlist, wlist, xlist, timeout=None):
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个参数都是一个数组，数组中的内容均为一个文件描述符(file descriptor)对象或者一个拥有返回文件描述符方法&lt;code&gt;fileno()&lt;/code&gt;的对象.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rlist: 就绪读list&lt;/li&gt;
&lt;li&gt;wlist: 就绪写list&lt;/li&gt;
&lt;li&gt;xlist: 异常的list&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;timeout&lt;/code&gt;参数是一个浮点类型的参数,如果不传或者为&lt;strong&gt;None&lt;/strong&gt;,那么调用将永远不会超时，也就是不会阻塞.&lt;/p&gt;
&lt;p&gt;返回值为函数传递的三个参数的元组, 每个为当前已经准备好的对应的描述符！&lt;/p&gt;
&lt;p&gt;我们来改写自己写的程序！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
import socket, select,json

l_addr=(&#39;127.0.0.1&#39;,8000)
def serve():
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind(l_addr)
    print(&amp;quot;listen: http://%s:%s&amp;quot; % l_addr)
    s.listen(5)
    inputs =[s,]
    outputs=[]
    s.setblocking(True)
    while True:
        r,w,e=select.select(inputs,outputs,inputs)
        print(&amp;quot;readables number: &amp;quot;, len(inputs))  #注释2
        for obj in r:
            if obj==s:
                conn,addr=obj.accept()
                conn.setblocking(0)
                inputs.append(conn)
            else:
                data_recv = obj.recv(1024)
                if not data_recv:
                    inputs.remove(obj)
                    if obj in outputs:
                        outputs.remove(obj)
                    obj.close()
                if data_recv:
                    if obj not in outputs:
                        outputs.append(obj)
        for obj in w:
            # print(&#39;deal socket...&#39;) # 注释1
            time.sleep(5)
            obj.send(&#39;HTTP/1.1 200 OK\r\n\r\n&#39;.encode())
            obj.sendall(json.dumps({&amp;quot;ret&amp;quot;:0,&amp;quot;msg&amp;quot;:&amp;quot;success&amp;quot;}).encode())
            e.append(obj)

        for obj in e:
            inputs.remove(obj)
            if obj in outputs:
                outputs.remove(obj)
            obj.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于上面的注释我在这里解释一下,前面说过select, poll, epoll本质上都是同步的I/O，因为它们都是在读写事件就绪后自己负责进行读写.所以说当它在负责读写的时候由于我们&lt;code&gt;sleep 5&lt;/code&gt;秒钟，那么所有的socket处理数据都会阻塞掉，在当我停止&lt;code&gt;ab&lt;/code&gt;压测时，由于当前的socket连接已经关闭，所以在&lt;strong&gt;注释1&lt;/strong&gt;处就会出现报错.&lt;strong&gt;注释2&lt;/strong&gt;是采用另一种方式验证,即统计当前就绪读状态下的&lt;strong&gt;socket&lt;/strong&gt;的数量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;listen: http://127.0.0.1:8000
readables number:  1
readables number:  2
readables number:  3
readables number:  4
readables number:  5
readables number:  6
readables number:  7
readables number:  8
readables number:  9
readables number:  10
readables number:  11
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们这里指定并发10个请求,再加上处于监听的socket刚好11个. 这也就验证了上面所在的io事件驱动本质:&lt;strong&gt;在接收请求中提供一种并发现象,在处理请求中本质是还是同步io&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;io事件poll&#34;&gt;io事件poll&lt;/h2&gt;
&lt;h4 id=&#34;select的缺点&#34;&gt;select的缺点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;select 最多只能监听1024个描述符，当然这可以通过重新编译Linux内核在改变这个值.&lt;/li&gt;
&lt;li&gt;每次对于监听的socket进行轮训查找是一个非常耗时的工作&lt;/li&gt;
&lt;li&gt;轮训的操作有linux内核来完成，也就是文件描述符要进入内核空间,从内核空间到用户空间的开销很大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际我在使用&lt;code&gt;ab&lt;/code&gt;做压测统计时发现就绪读列表中最多也就400个左右.&lt;/p&gt;
&lt;h4 id=&#34;poll的改进&#34;&gt;poll的改进&lt;/h4&gt;
&lt;p&gt;poll本质上和select没有区别，只是没有了最大连接数(linux上默认1024个)的限制，原因是它基于链表存储的。&lt;/p&gt;
&lt;h4 id=&#34;python中的poll&#34;&gt;python中的poll&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;select.poll()&lt;/code&gt;: 返回一个poll对象,并支持&lt;code&gt;sizehint&lt;/code&gt;参数来优化内部数据结构,该对象支持一下方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eventmask&lt;/strong&gt;表示一个可选的掩码位,用于描述要检查的事件类型,其值是一下的集合：
|   名称    |                  含义                  |
| :&amp;mdash;&amp;mdash;-: | :&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;: |
|  POLLIN   |                有数据读                |
|  POLLPRI  |              有数据紧急读              |
|  POLLOUT  |         数据输出，并且不会阻塞         |
|  POLLERR  |              某种错误情况              |
|  POLLHUP  |                 挂起T                  |
| POLLRDHUP | 准备关闭流socket或等待另外一半连接关闭 |
| POLLNVAL  |        无效的请求：描述符未打开        |&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;register(self, fd, eventmask=None)&lt;/code&gt;:  向poll对象中注册一个文件描述符,如果已经存在则抛出一个OS Error.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unregister(self, fd)&lt;/code&gt;:  从poll对象中删除已经注册的描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(self, fd, eventmask)&lt;/code&gt;: 修改一个已经注册的描述符,和&lt;code&gt;register&lt;/code&gt;功能类似,如果尝试修改一个没有注册的描述符会触发一个OS Error.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll(self, timeout=-1, maxevents=-1)&lt;/code&gt;: 轮训已经注册的文件描述符,返回一个包含&lt;code&gt;(fd,event)&lt;/code&gt;两个元素的元组列表. 如果列表为空则表示超时或者没有对应的io事件发生;&lt;code&gt;timeout&lt;/code&gt;表示系统等待返回事件的超时时间，单位毫秒；如果为None,负数,或者不指定则一直阻塞下去.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用此种模式改写我们自己的socket服务如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import select, socket,time,json

l_addr=(&#39;127.0.0.1&#39;,8000)
def server():
    # init socket
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind(l_addr)
    print(&amp;quot;listen: http://%s:%s&amp;quot; % l_addr)
    s.listen(1)
    s.setblocking(True)
    # init poll
    my_poll = select.poll()
    my_poll.register(s.fileno(),select.EPOLLIN)
    conn_dict={}
    try:
        while True:
            for fd, event in my_poll.poll():
                if event == select.POLLIN:
                    if fd == s.fileno():
                        conn,addr = s.accept()
                        conn.setblocking(False)
                        my_poll.register(conn.fileno(),select.EPOLLIN)
                        conn_dict[conn.fileno()]=conn
                    else:
                        print(&#39;poll in.....&#39;)
                        conn = conn_dict[fd]
                        data = conn.recv(1024)
                        if data:
                            my_poll.modify(conn.fileno(),select.POLLOUT)
                elif event == select.POLLOUT:
                    time.sleep(1)
                    # print(&#39;deal requests...&#39;)
                    conn = conn_dict[fd]
                    conn.send(&#39;HTTP/1.1 200 OK\r\n\r\n&#39;.encode())
                    conn.sendall(json.dumps({&amp;quot;ret&amp;quot;:0,&amp;quot;msg&amp;quot;:&amp;quot;success&amp;quot;}).encode())
                    my_poll.unregister(conn.fileno())
                    conn.close()
    except Exception as e:
        s.close()
    finally:
        print(123)
        s.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样的道理我们无法在请求处理过程中看到并发的效果(也就是&lt;code&gt;select.POLLOUT&lt;/code&gt;事件下),可以在&lt;code&gt;POLLIN&lt;/code&gt;事件中通过简单的打印来看并发的请求.&lt;/p&gt;
&lt;p&gt;当我们指定高并发时，比如100个,可以看到快速的&lt;code&gt;print&lt;/code&gt;出数据来.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ab -c 100 -n 1000 http://localhost:8000/
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;io事件epoll&#34;&gt;io事件epoll&lt;/h2&gt;
&lt;h4 id=&#34;poll的缺点&#34;&gt;poll的缺点&lt;/h4&gt;
&lt;p&gt;poll解除select最大1024个描述符限制,其他的和select类似.事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。&lt;/p&gt;
&lt;h4 id=&#34;什么是epoll&#34;&gt;什么是epoll&lt;/h4&gt;
&lt;p&gt;epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。&lt;/p&gt;
&lt;p&gt;关于上面的缺点epoll使用了一下方案来解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内核copy&lt;/strong&gt; 在底层使用**mmap()**文件映射的方式加速与内核空间的数据传递&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大连接数&lt;/strong&gt; 最大连接数取决你操作系统定义的&lt;strong&gt;file_max&lt;/strong&gt;,也就是说取决与操作系统的限制,而且这个值可以修改.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fd轮训&lt;/strong&gt; epoll采用了回调的机制来管理已就绪的fd,所以epoll永远管理的是一个已就绪的列表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有一个思考，epoll更像是一个高贵的公子,自己拿到的东西永远都是已经准备好的(就绪的fd),但是是谁在为它准备这些已就绪的fd呢？ 看有些文章说是Python底层在做这件事情.&lt;/p&gt;
&lt;p&gt;epoll对与fd的操作有两种模式： &lt;strong&gt;LT level trigger(水平出发)&lt;/strong&gt; 和 &lt;strong&gt;ET edge trigger(边沿触发)&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LT模式：当检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。&lt;/li&gt;
&lt;li&gt;ET模式：当检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;python中的epoll&#34;&gt;python中的epoll&lt;/h4&gt;
&lt;p&gt;epoll模型也是在select模块中，如果需要一个epoll对象直接实例化就可以了！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;epoll = select.epoll(sizehint=-1, flags=0)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;sizehint： 这个参数没有太多的意义，仅仅使用在没有&lt;code&gt;epoll_create1()&lt;/code&gt;系统调用的老系统中&lt;/li&gt;
&lt;li&gt;flags： 这个参数已弃用，在python3.4之后就直接使用&lt;strong&gt;select.EPOLL_CLOEXEC&lt;/strong&gt;,不用管.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且在3.4之后支持和&lt;code&gt;with&lt;/code&gt;语句一起协同工作.&lt;/p&gt;
&lt;p&gt;epoll中的事件:
|    名称     |                  含义                  |
| :&amp;mdash;&amp;mdash;&amp;mdash;: | :&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;: |
|   EPOLLIN   |                 读就绪                 |
|  EPOLLOUT   |                 写就绪                 |
|  EPOLLPRI   |              有数据紧急读              |
|  EPOLLERR   |          assoc,fd 上发生错误           |
|  EPOLLHUP   |          assoc,fd 上发生挂起           |
|   EPOLLET   |      设置边沿触发，默认是水平触发      |
| EPOLLRDHUP  | 准备关闭流socket或等待另外一半连接关闭 |
| EPOLLRDNORM |             和EPOLLIN一样              |
| EPOLLRDBAND |          可以读取高优先级数据          |
| EPOLLWRNORM |             和EPOLLOUT一样             |
| EPOLLWRNORM |          可以写取高优先级数据          |
|  EPOLLMSG   |                  忽略                  |&lt;/p&gt;
&lt;p&gt;epoll中提供了一下方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;register(self, fd, eventmask=None)&lt;/code&gt; 向epoll中注册一个fd,如果已经存在就会包OS Error.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unregister(self, fd)&lt;/code&gt; epoll中注销一个fd.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll(self,timeout=-1, maxevents=-1)&lt;/code&gt; 在epoll的fd中等待事件发生&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(self, fd, eventmask)&lt;/code&gt; 修改一个fd的事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;/code&gt; 关闭epoll对象描述符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fileno()&lt;/code&gt; 返回当前epoll对象的fd.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用epoll改写我们程序如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import select,socket,json,time

l_addr=(&#39;127.0.0.1&#39;,8000)


def server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(l_addr)
    s.listen(1)
    print(&amp;quot;listen: http://%s:%s&amp;quot; % l_addr)
    s.setblocking(0)
    epoll = select.epoll()
    epoll.register(s.fileno(),select.EPOLLIN)
    try:
        conn_dict={}
        while True:
            events = epoll.poll()
            print(len(events))   #注释1
            for fd, event in events:
                if event == select.EPOLLIN:
                    if fd == s.fileno():
                        conn,addr = s.accept()
                        conn.setblocking(False)
                        epoll.register(conn.fileno(),select.EPOLLIN)
                        conn_dict[conn.fileno()]=conn
                    else:
                        print(&#39;input request...&#39;)  #注释2
                        conn = conn_dict[fd]
                        time.sleep(1)
                        data = conn.recv(1024)
                        if data:
                            epoll.modify(conn.fileno(),select.EPOLLOUT)
                elif event == select.EPOLLOUT:
                    conn = conn_dict[fd]
                    conn.send(&#39;HTTP/1.1 200 OK\r\n\r\n&#39;.encode())
                    conn.sendall(json.dumps({&amp;quot;ret&amp;quot;:0,&amp;quot;msg&amp;quot;:&amp;quot;success&amp;quot;}).encode())
                    conn.shutdown(socket.SHUT_RDWR)
                elif event == select.EPOLLHUP:
                    conn = conn_dict[fd]
                    epoll.unregister(conn.fileno())
                    conn.close()
    finally:
        epoll.unregister(s.fileno())
        epoll.close()
        s.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用上面的&lt;code&gt;ab&lt;/code&gt;压测你会发现&lt;strong&gt;注释1&lt;/strong&gt;和并发的连接数是一样的大约在100个左右(ab一次100个并发),在&lt;strong&gt;注释2&lt;/strong&gt;处的接收请求数据很快就打印100个，和poll类似.&lt;/p&gt;
&lt;h2 id=&#34;高级别selectors模块&#34;&gt;高级别selectors模块&lt;/h2&gt;
&lt;p&gt;这个模块是&lt;code&gt;select&lt;/code&gt;扩展,可以根据用户的系统选择合适的io模型，官方也鼓励使用这个模块.这里就不多讲解了,贴一下&lt;strong&gt;server_forver&lt;/strong&gt;的源码供大家参考:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with _ServerSelector() as selector:
    selector.register(self, selectors.EVENT_READ)

    while not self.__shutdown_request:
        ready = selector.select(poll_interval)
        # bpo-35017: shutdown() called during select(), exit immediately.
        if self.__shutdown_request:
            break
        if ready:
            self._handle_request_noblock()

        self.service_actions()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;事件驱动I/O的一个潜在的优势在于它可以在不使用多线程或者多进程的情况下同时处理大量的连接.也就是说,&lt;code&gt;select()&lt;/code&gt;可以来监视成千上百个socket,并且对他们中间发送的事件做出响应.&lt;/p&gt;
&lt;p&gt;事件驱动的缺点在于这里没有涉及真正的并发.如果一个事件的处理方法阻塞了或者执行了一个较长的耗时计算(也就是我们在列子中指定的&lt;code&gt;sleep&lt;/code&gt;函数),那么之后所有的处理请求过程都会阻塞.&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&#34;https://github.com/busyboy-ws/my_code/tree/master/python/io_event&#34;&gt;https://github.com/busyboy-ws/my_code/tree/master/python/io_event&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/http/http-messages.html&#34;&gt;HTTP消息结构&lt;/a&gt;
&lt;a href=&#34;https://www.jianshu.com/p/abfb47d36fba&#34;&gt;Linux下I/O多路复用select, poll, epoll 三种模型的Python使用&lt;/a&gt;
&lt;a href=&#34;http://scotdoyle.com/python-epoll-howto.html&#34;&gt;How To Use Linux epoll with Python&lt;/a&gt;
&lt;a href=&#34;https://docs.python.org/3/library/select.html#poll-objects&#34;&gt;select — Waiting for I/O completion&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Werkzuge的一次请求和响应</title>
      <link>/post/werkzuge-request/</link>
      <pubDate>Tue, 04 Feb 2020 16:01:23 +0800</pubDate>
      
      <guid>/post/werkzuge-request/</guid>
      
        <description>&lt;h2 id=&#34;werkzuge示例&#34;&gt;werkzuge示例&lt;/h2&gt;
&lt;p&gt;一个简单的werkzuge示例如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import json
from werkzeug.wrappers import Request, Response
from werkzeug.serving import run_simple

@Request.application
def application(request):
    response = Response(json.dumps({&#39;code&#39;:0, &#39;msg&#39;: &#39;success&#39;}),status=200)
    return response

if __name__ == &#39;__main__&#39;:
    run_simple(&#39;localhost&#39;,8000,application)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行werkzeug的程序的入口为&lt;code&gt;serving&lt;/code&gt;文件的&lt;code&gt;run_simple&lt;/code&gt;函数,该函数通过调用&lt;code&gt;make_server&lt;/code&gt;函数来创建一个&lt;em&gt;Server&lt;/em&gt;类,这个类继承了从&lt;strong&gt;HTTP&lt;/strong&gt;到底层的&lt;strong&gt;socket&lt;/strong&gt;类，通过运行&lt;strong&gt;serve_forever&lt;/strong&gt;方法来实现接收数据和处理数据.&lt;/p&gt;
&lt;h2 id=&#34;wsgi类的关联关系&#34;&gt;WSGI类的关联关系&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;make_server&lt;/code&gt;中使用了多个WSGI的类,分别是&lt;strong&gt;BaseWSGIServer&lt;/strong&gt;,&lt;strong&gt;ForkingWSGIServer&lt;/strong&gt;,&lt;strong&gt;ThreadedWSGIServer&lt;/strong&gt;;不难看出后面两个是对&lt;strong&gt;BaseWSGIServer&lt;/strong&gt;提供的多进程和多线程的支持.他们之间的继承关系如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            BaseWSGIServer
            //        \\
           //          \\
ForkingWSGIServer   ThreadedWSGIServer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一切的起源都是&lt;strong&gt;BaseWSGIServer&lt;/strong&gt;，来看看这个类的作用.&lt;/p&gt;
&lt;h2 id=&#34;basewsgiserver的继承&#34;&gt;BaseWSGIServer的继承&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    BaseServer(socketserver)
            ||
            ||
        TCPServer(socketserver)
            ||
            ||
        HTTPServer(http/server)
            ||
            ||
    BaseWSGIServer(werkzeug/server)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;basewsgiserver类的方法和属性&#34;&gt;BaseWSGIServer类的方法和属性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BaseWSGIServer&lt;/strong&gt;继承于&lt;strong&gt;HTTPServer&lt;/strong&gt;,也就不难看出WSGI是连接web服务器与和应用程序之前的座桥梁. 详细请参考这篇文章: &lt;a href=&#34;http://mitsuhiko.pocoo.org/wzdoc/wsgihowto.html&#34;&gt;Werkzeug How WSGI Works&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;属性&#34;&gt;属性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;host and port: 需要监听的ip地址和端口，也是通常所说的socket.&lt;/li&gt;
&lt;li&gt;applicaion: web服务其要与之交互的应用程序.&lt;/li&gt;
&lt;li&gt;handler: 用作处理请求的handler类，也是实际由它实现了WSGI的功能和应用程序交互.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道在编写&lt;strong&gt;socketserver&lt;/strong&gt;模块的服务端代码时,真正处理请求的是由我们自定义的&lt;code&gt;Handler&lt;/code&gt;实现的. 而&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;werkzeug&lt;/code&gt;都继承了这一思想，将处理请处理的方法放在&lt;strong&gt;Handler&lt;/strong&gt;中，并在开始处理请求时实例化这个类. 默认&lt;code&gt;Handler&lt;/code&gt;采用的是&lt;strong&gt;WSGIRequestHandler&lt;/strong&gt;这个类. 初始化时如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if handler is None:
    handler = WSGIRequestHandler
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;serve_forever监听socket&#34;&gt;serve_forever()监听socket&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;BaseWSGIServer&lt;/strong&gt; 虽然自己从新实现了&lt;strong&gt;server_forever&lt;/strong&gt;方法, 但并未做太多的事情，真正实现socket的数据接受和处理还是&lt;strong&gt;BaseServer&lt;/strong&gt;中的这个方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    with _ServerSelector() as selector:
        selector.register(self, selectors.EVENT_READ)

        while not self.__shutdown_request:
            ready = selector.select(poll_interval)
            # bpo-35017: shutdown() called during select(), exit immediately.
            if self.__shutdown_request:
                break
            if ready:
                self._handle_request_noblock()

            self.service_actions()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;selector&lt;/code&gt;实现io的多路复用，它可以根据操作系统平台实现不同的io多路复用机制，常见的是&lt;code&gt;select&lt;/code&gt;,&lt;code&gt;poll&lt;/code&gt;,&lt;code&gt;epoll&lt;/code&gt;. 可以看到当有请求进来时调用了内部的&lt;code&gt;_handle_request_noblock&lt;/code&gt;方法处理请求.&lt;/p&gt;
&lt;h4 id=&#34;get_request-方法&#34;&gt;get_request 方法&lt;/h4&gt;
&lt;p&gt;当一个请求进来时，werkzegu重写了&lt;strong&gt;get_request&lt;/strong&gt;方法来建立客户端连接，返回一个请求的socket对象和客户端地址信息.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    con, info = self.socket.accept()
    return con, info
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在函数内部调用&lt;code&gt;verify_request&lt;/code&gt;和&lt;code&gt;process_request&lt;/code&gt;实现对请求的验证和处理，这些实现还是在socketserver模块定义的&lt;strong&gt;BaseServer&lt;/strong&gt;类中. 之后由&lt;code&gt;finish_request&lt;/code&gt;这个方法实例化一个请求的&lt;strong&gt;handler&lt;/strong&gt;类处理socket.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def finish_request(self, request, client_address):
    &amp;quot;&amp;quot;&amp;quot;Finish one request by instantiating RequestHandlerClass.&amp;quot;&amp;quot;&amp;quot;
    self.RequestHandlerClass(request, client_address, self)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是WSGI的&lt;code&gt;handler&lt;/code&gt;如何继承底层sockerserver的&lt;code&gt;handler&lt;/code&gt;;可以看到和&lt;strong&gt;BaseWSGIServer&lt;/strong&gt;的继承是一个样子.&lt;/p&gt;
&lt;h2 id=&#34;wsgirequesthandler的继承关系&#34;&gt;WSGIRequestHandler的继承关系&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;    BaseRequestHandler(socketserver)
            ||
            ||
    StreamRequestHandler(socketserver)
            ||
            ||
    BaseHTTPRequestHandler(http/server)
            ||
            ||
    WSGIRequestHandler(werkzeug/server)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到&lt;strong&gt;BaseRequestHandler&lt;/strong&gt;接收一下属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;request: 每个请求的socket实例&lt;/li&gt;
&lt;li&gt;client_address： 客户端连接地址和端口&lt;/li&gt;
&lt;li&gt;server: 当前处理请求的server，对werkzeug来说就是&lt;code&gt;BaseWSGIServer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;handler&lt;/em&gt;的实例化还是由基类&lt;strong&gt;BaseRequestHandler&lt;/strong&gt;来实现的，之后一次调用&lt;code&gt;setup()&lt;/code&gt;,&lt;code&gt;handler()&lt;/code&gt;，&lt;code&gt;finish()&lt;/code&gt;方法来完成处理请求. 此处的&lt;strong&gt;BaseRequestHandler&lt;/strong&gt;则是一个接口，定义了需要实现的方法，而所有的具体方法处理逻辑则有对应派生类实现。&lt;/p&gt;
&lt;h4 id=&#34;setup方法&#34;&gt;setup()方法&lt;/h4&gt;
&lt;p&gt;注： 由于HTTP是基于TCP协议的，而这个&lt;strong&gt;setup()&lt;strong&gt;方法也是&lt;/strong&gt;StreamRequestHandler&lt;/strong&gt;(TCP)实现的.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义了&lt;code&gt;rfile&lt;/code&gt;和&lt;code&gt;wfile&lt;/code&gt;分别实现对socket的读和写. rfile设置了读缓存，wfile则没有缓存。&lt;/li&gt;
&lt;li&gt;是否禁用nagle 算法.&lt;/li&gt;
&lt;li&gt;设置超时时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;handle方法&#34;&gt;handle()方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;WSGIRequestHandler&lt;/strong&gt;本身也只是调用父类的&lt;strong&gt;handler&lt;/strong&gt;方法,之后调用了&lt;strong&gt;handle_one_request&lt;/strong&gt;,WSGI重写了这个方法，主要做了三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取http的请求行，也就是 &lt;strong&gt;GET /hello.txt HTTP/1.1\r\n&lt;/strong&gt;,这样的二进制流数据.&lt;/li&gt;
&lt;li&gt;解析获取到的请求行，并封装成&lt;code&gt;request method&lt;/code&gt;,&lt;code&gt;request path&lt;/code&gt;,&lt;code&gt;request version&lt;/code&gt; 和 获取请求头数据，并验证连接是否关闭.&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;run_wsgi()&lt;/code&gt; 实现后续的数据处理.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;run_wsgi方法&#34;&gt;run_wsgi()方法&lt;/h4&gt;
&lt;p&gt;根据PEP333的规范，在服务器或网关的开发中，应用程序必须要接受两个位置参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;environ： 是一个字典对象，包含CGI样式的环境变量，而且必须是内置的Python字典.&lt;/li&gt;
&lt;li&gt;start_response： 是一个可调用对象，一般来说可以是一个函数.
具体请参考PEP333官方文档:&lt;a href=&#34;https://www.python.org/dev/peps/pep-0333/&#34;&gt;https://www.python.org/dev/peps/pep-0333/&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Werkzeug的具体实现为： 在进入函数时通过&lt;code&gt;make_environ&lt;/code&gt;函数生成当前wsgi所拥有的环境变量，通过&lt;code&gt;execute&lt;/code&gt;方法将应用程序传递进来，也就是我们开头设置的应用程序.&lt;/p&gt;
&lt;p&gt;对于每个应用程序来说都加了&lt;code&gt;Request.application&lt;/code&gt;这个类装饰器. 装饰器接收的参数也是wsgi提供的&lt;code&gt;envrion&lt;/code&gt;和&lt;code&gt;response&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def application(*args):
    request = cls(args[-2])
    with request:
        try:
            resp = f(*args[:-2] + (request,))
        except HTTPException as e:
            resp = e.get_response(args[-2])
        return resp(*args[-2:])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此处&lt;em&gt;request&lt;/em&gt;为当前函数所在的类的实例，&lt;em&gt;f&lt;/em&gt; 为我们执行应用程序对应的函数. 返回的&lt;em&gt;resp&lt;/em&gt;也就是我们在应用程序中返回的对象,当一个可调用对象调用时会首先查找自己的&lt;code&gt;__call__&lt;/code&gt;方法，此时这个装饰器返回的对象也就是&lt;strong&gt;Response&lt;/strong&gt;中&lt;code&gt;__call__&lt;/code&gt;方法返回的数据。&lt;/p&gt;
&lt;h4 id=&#34;response__call__方法&#34;&gt;Response.__call__方法&lt;/h4&gt;
&lt;p&gt;处理WSGI引用程序提供的响应数据，参数分别为WSGI的环境变量字典&lt;code&gt;environ&lt;/code&gt;和&lt;strong&gt;Handler&lt;/strong&gt;类中的&lt;strong&gt;start_response&lt;/strong&gt;,函数返回一个迭代器，响应的数据都放在这个迭代器中.&lt;/p&gt;
&lt;p&gt;一个http的响应依次为首行，响应头，响应体如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个函数中通过&lt;code&gt;environ&lt;/code&gt;变量封装了对应的状态码和响应头，状态码是在应用程序中调用&lt;strong&gt;Response&lt;/strong&gt;类实例化时就直接当成属性的方式赋值的，而响应头则调用&lt;strong&gt;get_wsgi_headers&lt;/strong&gt;函数构造. 之后就开始调用&lt;strong&gt;start_response&lt;/strong&gt;构造响应的数据.&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;start_response&lt;/strong&gt;中将响应放在了&lt;code&gt;headers_set&lt;/code&gt;这个列表中，而这个&lt;code&gt;headers_set&lt;/code&gt;是个&lt;code&gt;run_wsgi&lt;/code&gt;变量通过闭包的形式修改.&lt;/p&gt;
&lt;p&gt;而实际响应的数据则由放在了迭代器&lt;code&gt;app_iter&lt;/code&gt;中.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    application_iter = app(environ, start_response)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来便是通过socket发送数据了. 来看一下&lt;strong&gt;write&lt;/strong&gt;方法.&lt;/p&gt;
&lt;h4 id=&#34;write函数&#34;&gt;write函数&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;封装请求行
&lt;code&gt;write&lt;/code&gt;行数在响应数据之前先通过放在&lt;code&gt;headers_set&lt;/code&gt;列表构造响应头和响应行. 并调用&lt;code&gt;send_response&lt;/code&gt;行数发送响应行.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;if self.request_version != &amp;quot;HTTP/0.9&amp;quot;:
    hdr = &amp;quot;%s %d %s\r\n&amp;quot; % (self.protocol_version, code, message)
    self.wfile.write(hdr.encode(&amp;quot;ascii&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;封装响应头
之后封装响应头数据，并通过&lt;code&gt;send_header&lt;/code&gt;函数发送响应头.而&lt;code&gt;send_header&lt;/code&gt;只是将所有的请求头格式化放在一个列表中用于缓存,之后封装了一些基本的http响应头,如：&lt;strong&gt;Server&lt;/strong&gt;,&lt;strong&gt;Date&lt;/strong&gt;,结束后调用&lt;strong&gt;end_headers&lt;/strong&gt;函数封装最后的&lt;code&gt;\r\n&lt;/code&gt;并通过&lt;code&gt;flush_headers&lt;/code&gt;函数将数据发送出去.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送响应数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;if data:
    # Only write data if there is any to avoid Python 3.5 SSL bug
    self.wfile.write(data)
self.wfile.flush()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后通过调用迭代器的&lt;code&gt;close()&lt;/code&gt;方法关闭数据. 次数WSGI侧数据的数据发送已经完成.&lt;/p&gt;
&lt;h2 id=&#34;关闭socket&#34;&gt;关闭Socket&lt;/h2&gt;
&lt;p&gt;此情况为一个socket连接响应一个请求，所以在响应完成后&lt;code&gt;Handler&lt;/code&gt;的&lt;strong&gt;close_connection&lt;/strong&gt;会被设置为True,此时开始关闭socket.
首先调用&lt;strong&gt;finish&lt;/strong&gt;函数对&lt;code&gt;wfile&lt;/code&gt;和&lt;code&gt;rfile&lt;/code&gt;进行关闭;然后在调用&lt;strong&gt;shutdown_request&lt;/strong&gt;对应socket进行关闭.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def handle(self):
    &amp;quot;&amp;quot;&amp;quot;Handle multiple requests if necessary.&amp;quot;&amp;quot;&amp;quot;
    self.close_connection = True

    self.handle_one_request()
    while not self.close_connection:
        self.handle_one_request()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由&lt;code&gt;handler&lt;/code&gt;可以看出在处理请求之前就在&lt;code&gt;close_connection&lt;/code&gt;属性设置为True，也就无法重用一个Socket.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Python 技巧</title>
      <link>/post/python-skill/</link>
      <pubDate>Mon, 30 Sep 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/python-skill/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;首先说明,这只是一些常见的使用技巧或者方法,你完全可以使用别的方式实现.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;1遵循pep-8风格&#34;&gt;1.遵循PEP 8风格&lt;/h4&gt;
&lt;p&gt;PEPE 8是针对Python代码格式而编写的风格指南.目的是让每个开发人员遵循同一种风格来编写代码，这样书写可以使代码更加易懂、易读;方便自己,也方便他人. PEP8 的指南在其官网地址为:&lt;a href=&#34;https://www.python.org/dev/peps/pep-0008/&#34;&gt;链接&lt;/a&gt;,这里列出几条绝对要准许的规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空白&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和语法相关,Python中每个缩进都应该是4个空格,而不是一个tab(制表符)&lt;/li&gt;
&lt;li&gt;同一个类中,每个方法之间应该用一个空行隔开&lt;/li&gt;
&lt;li&gt;变量赋值时,等号左右应该各写一个空格,而且只写一个&lt;/li&gt;
&lt;li&gt;同一文件中,函数和类用两个空行隔开&lt;/li&gt;
&lt;li&gt;每行的字符数不应该超过80,多出来的应该换行书写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数、变量名、属性应该采用小写加下划线的方式&lt;/li&gt;
&lt;li&gt;内部属性应该以单下划线开头,例如：_name&lt;/li&gt;
&lt;li&gt;私有属性应该以双下划线开头,例如: __name&lt;/li&gt;
&lt;li&gt;自定义的异常或者类应该使用驼峰法来命名,例如: PreRequest&lt;/li&gt;
&lt;li&gt;模块级别的常量应该采用大写字符加下划线的方式,例如:DEFAULT_PORTS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;表达式和语句&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测列表长度是否为0时,不要使用&lt;code&gt;if len(list) == 0&lt;/code&gt;方式,而是直接采用空值检测&lt;code&gt;if not list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;import 导入模块时,首先是标准库、第三方库、自用库&lt;/li&gt;
&lt;li&gt;否定形式应该在表达式内部,而不是再次取反 如: &lt;code&gt;if a is not b &lt;/code&gt;而不是&lt;code&gt;if not a is b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;包导入时应该使用绝对路径,而不是使用相对路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2列表推导式代替函数&#34;&gt;2.列表推导式代替函数&lt;/h4&gt;
&lt;p&gt;对于数据较少的列表来说,我们需要改变列表中每个元素的内容,这时应该使用列表推导式而不是map, filter或自定义函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [1]: a = [1,2,3,4,5,6]
In [2]: [x * 2 for x in a ]
Out[2]: [2, 4, 6, 8, 10, 12]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于列表推导式来说,这样的方法类似于采用&lt;code&gt;for&lt;/code&gt;循环,当然列表推导式也支持多层循环,但实际中不推荐这样使用。&lt;/p&gt;
&lt;h4 id=&#34;3生成器替代大列表推导式&#34;&gt;3.生成器替代大列表推导式&lt;/h4&gt;
&lt;p&gt;对于读取文件，Socket等大数据量特别大的操作时,应该使用迭代器来生成每个数据,而不能使用列表推导式一次把数据全部读到内存.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [6]: a = (print(x) for x in open(&#39;/etc/passwd&#39;))
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;4for-while循环后面不要写else&#34;&gt;4.for while循环后面不要写else.&lt;/h4&gt;
&lt;p&gt;Python为for和while两种循环都添加了else语法,但实际使用起来并不是很好用,由于对&lt;code&gt;if else&lt;/code&gt;的理解,我们很容易理解为如果循环没有正常执行,那么就执行else块。 但实际却刚好相反。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [9]: for i in [1,2,3]:
   ...:     print(i)
   ...:     if i ==2:
   ...:         break
   ...: else:
   ...:     print(&#39;else break&#39;)
1
2
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;In [10]: for i in [1,2,3]:
    ...:     print(i)
    ...: else:
    ...:     print(&#39;else break&#39;)
    ...:
1
2
3
else break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这种写法,有过其他语言基础的编程者会感到很不能理解,所以最好的方式就是不在循环后面添加else.&lt;/p&gt;
&lt;h4 id=&#34;5-if多分枝嵌套&#34;&gt;5. if多分枝嵌套&lt;/h4&gt;
&lt;p&gt;我们经常可以看到对于一个新手写的代码中有大量的分支嵌套语句,也就是这样&lt;code&gt;if{ if { if { }}}&lt;/code&gt;.但对于Python来说这样的做法更糟糕,因为缩进的原因,这很容易超出每行数字的限制.&lt;/p&gt;
&lt;p&gt;我们以一段伪代码来看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if 商店开门:
    if 有苹果:
        if 钱足够:
            do_buy_apple();
        else:
            print(&#39;钱不够&#39;)
    else:
        print(&#39;没有苹果&#39;)
else:
    print(&#39;商店没开门&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的代码可读性和维护性都比较差,我们完全可以使用&lt;em&gt;提前结束&lt;/em&gt;来优化代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if not 商店开门:
	print(&#39;商店没开门&#39;)
if not 有苹果:
	print(&#39;没有苹果&#39;)
if not 钱足够:
    print(&#39;钱不够&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;6函数应该返回同一种类型&#34;&gt;6.函数应该返回同一种类型&lt;/h4&gt;
&lt;p&gt;Python的函数可以返回多个元素,也可以返回不同类型，这看起来是一件好事；我们可以使用同一个函数通过返回不同结果来实现多种功能。但个人认为，Python中的函数应该遵循单一职责原则,每个函数应该做好自己的事情提供稳定的返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def get_users(user_id=None):
    if user_id is None:
        return User.get(user_id)
    else:
        return User.filter(is_active=True)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上例子,应该讲这个函数功能拆分为&lt;code&gt;get_user_by_id&lt;/code&gt;和&lt;code&gt;get_active_user.&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;7-函数中args-kwargs减少参数数量&#34;&gt;7. 函数中*args, **kwargs减少参数数量&lt;/h4&gt;
&lt;p&gt;Python中的函数接受参数可以分为位置参数，关键字参数,一般来说我们可以无限制的在Python的形参位置上传递参数,但是这样看起来相当臃肿.*args、**kwargs可以帮助我们解决这个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*args 接受任意的位置参数,会将其参数当做一个元组&lt;/li&gt;
&lt;li&gt;**kwargs 接受任意的关键字参数, 其参数会被当做一个字典&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;def do_alarm(alerm_type,alarm_subject_template,expMessage,alarm_message_template,sms_message,user_phone,user_email,dingding_address):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;def do_alarm(alerm_type, *args, **kwargs):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;8-上下文管理器读取文件&#34;&gt;8. 上下文管理器读取文件&lt;/h4&gt;
&lt;p&gt;Python中读取文件使用的是&lt;code&gt;Open&lt;/code&gt;函数,但是这样有一个非常大的缺点,我们总是在读取完文件后忘记关闭文件描述符,所以我们通常采用&lt;code&gt;with&lt;/code&gt;语句来管理读取的文件对象,这样在&lt;code&gt;with&lt;/code&gt;语句结束后会自行帮我们关闭文件描述符.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [11]: with open(&#39;/etc/passwd&#39;) as file:
    ...:     print(file.read())
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们只解决文件描述符关闭的问题,但对于大文件读取我们任然需要注意。 &lt;code&gt;file.read()&lt;/code&gt;是将文件中的内容一次性的全部读取完毕，如果是一个10G那么仅仅一个文件读操作就消耗了所有的内存。&lt;/p&gt;
&lt;p&gt;通常，我们有两种做法来解决这个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分片读取,每次读取一定量的数据字节,这和&lt;code&gt;readline()&lt;/code&gt;或&lt;code&gt;readlines()&lt;/code&gt;是同一个道理。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;生成器解耦&lt;/em&gt;,这是生成器的强项.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;def file_read(fd,chunk=512):
    while True:
        read_data = fd.read(chunk)
        if not read_data:
            break
        yield read_data
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;9-循环替代递归&#34;&gt;9. 循环替代递归&lt;/h4&gt;
&lt;p&gt;递归是函数自身调用自己的一种形式,但是Python对于递归的支持并不是很好,而且在递归的层数上还有很大的限制,最多是999层.&lt;/p&gt;
&lt;p&gt;所以我建议：&lt;strong&gt;尽量少写递归&lt;/strong&gt;。如果你想用递归解决问题，先想想它是不是能方便的用循环来替代。如果答案是肯定的，那么就用循环来改写吧。&lt;/p&gt;
&lt;h4 id=&#34;10类的设计思想&#34;&gt;10.类的设计思想&lt;/h4&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://www.zlovezl.cn/articles/write-solid-python-codes-part-1/&#34;&gt;连接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要思想来自于SOLID设计原则。&lt;/p&gt;
&lt;p&gt;S: 单一职责原则&lt;/p&gt;
&lt;p&gt;O: 开放封闭原则&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实用技巧&lt;/p&gt;
&lt;h4 id=&#34;11-原地交换数字&#34;&gt;11. 原地交换数字&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;x, y = 10, 20
x, y = y,x
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;12-列表去重&#34;&gt;12. 列表去重&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;In [24]: l = [1,2,2,3,3,3]
In [26]: {}.fromkeys(l).keys()
Out[26]: dict_keys([1, 2, 3])

In [27]: list(set(l))
Out[27]: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述提供了两种去重的方法，但是对于大列表而言他们的性能又有很多差异。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [29]: l = [ random.randint(1,50) for i in range(100000)]
In [33]: %time {}.fromkeys(l).keys()                                                     CPU times: user 1.91 ms, sys: 0 ns, total: 1.91 ms
Wall time: 1.91 ms

In [34]: %time list(set(l))                                                               CPU times: user 952 µs, sys: 0 ns, total: 952 µs
Wall time: 954 µs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到第二种方法效率更高。&lt;/p&gt;
&lt;h4 id=&#34;13__slots__-大量属性时减少内存占用&#34;&gt;13.__slots__ 大量属性时减少内存占用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class User(object):
...     __slots__ = (&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;)
...     def __init__(self, name, age):
...         self.name = name
...         self.age = age
...
&amp;gt;&amp;gt;&amp;gt; u = User(&amp;quot;Dong&amp;quot;, 28)
&amp;gt;&amp;gt;&amp;gt; hasattr(u, &amp;quot;__dict__&amp;quot;)
False
&amp;gt;&amp;gt;&amp;gt; u.title = &amp;quot;xxx&amp;quot;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;User&#39; object has no attribute &#39;title
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;14-多用collections模块&#34;&gt;14. 多用collections模块&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Count 统计频率&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [44]: a = collections.Counter(l)
In [45]: a.most_common()                                                                  Out[45]: [(6, 5), (1, 3), (5, 3), (9, 2), (3, 2), (2, 2), (10, 1), (8, 1), (7, 1)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;deque优化的列表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [47]: collections.deque?
Init signature: collections.deque(self, /, *args, **kwargs)
Docstring:
deque([iterable[, maxlen]]) --&amp;gt; deque object
A list-like sequence optimized for data accesses near its endpoints.
File:           /usr/local/miniconda3/envs/py3.6/lib/python3.6/collections/__init__.py
Type:           type
Subclasses:     Deque
In [48]: Q = collections.deque()
In [49]: Q.append(1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;OrderedDict 有序字典&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defaultdict 默认字典&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;15-pathlib-模块操作目录&#34;&gt;15. pathlib 模块操作目录&lt;/h4&gt;
&lt;p&gt;这里写一个简单的路径拼接的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [67]: import os
In [68]: os.path.join(&#39;/tmp&#39;, &#39;foo.txt&#39;)
Out[68]: &#39;/tmp/foo.txt&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;In [70]: Path(&#39;/tmp&#39;) / &#39;foo.txt&#39;                                                         Out[70]: PosixPath(&#39;/tmp/foo.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>记录一次公司的网络丢包</title>
      <link>/post/mysql-network/</link>
      <pubDate>Sun, 04 Aug 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/mysql-network/</guid>
      
        <description>&lt;p&gt;最近公司网络出现一个很诡异的现象,Navicat连接阿里云数据库等待一段时间(大约5s)之后,再次执行相应的SQL语句会变的异常卡顿,经过排查问题出现在我们的防火墙设备上,以下是排查过程.&lt;/p&gt;

&lt;h2 id=&#34;一现象描述&#34;&gt;一、现象描述&lt;/h2&gt;

&lt;p&gt;大约在15号下午左右,开发人员反馈Navicat连接阿里云数据库非常的卡顿,平时秒级的查询今天要查询很久,无法忍受。&lt;/p&gt;

&lt;p&gt;接开发人员反馈后立即登陆到本地的一个ubuntu机器进行网络测试,因为从现象上来看可以大致判断这是一个网络问题,于是ping对应的RDS数据后发现网络并没有什么异常。&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;/images/network/1571364084275.png&#34; alt=&#34;1571364084275&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;从上图标红可以看到丢包率为0,每个包的延迟都在3ms左右,可以说是非常的正常,这也说明我们的公司网络整体是正常的。&lt;/p&gt;

&lt;p&gt;既然问题是出现在MySQL上,用Navicat现象不明显,此时也就在本地的一台ubuntu机器上使用MySQL客户端连接并抓包来分析一下。发现从数据库认证到执命令是正常的，但隔一段时间后再次执行一条简单的&lt;code&gt;show databases&lt;/code&gt;语句就会卡住,一下是抓包的结果.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;/images/network/1571364627507.png&#34; alt=&#34;1571364627507&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;从上面的抓包来看,MySQL客户端户在一次查询语句之后不停的发送TCP Retransmission 重传包,于是问题就清楚了,客户端连接到服务端后发送的包丢失了,这会有一下情况:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RDS没有收到客户的查询请求,也就是说包本身没有到服务端&lt;/li&gt;
&lt;li&gt;RDS本身有问题,没有响应客户端的请求&lt;/li&gt;
&lt;li&gt;RDS响应了客户端的请求,但是客户端没有接受到对应的响应&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二排查问题&#34;&gt;二、排查问题&lt;/h2&gt;

&lt;p&gt;从以上情况可以得知,问题出现在服务端、客户端、公网都是有可能的,但是公网不受我们控制,而且即使出现问题也只能找对应的供应商协同排查,所我们先从以下两侧分析.&lt;/p&gt;

&lt;h4 id=&#34;1服务端侧排查&#34;&gt;1、服务端侧排查&lt;/h4&gt;

&lt;p&gt;由于数据库是阿里云的RDS,我们联系了对应的阿里云工程师查看了RDS的内外网状态,从之前的经验上来看,我更倾向于是阿里云RDS所有在网络的出口IP设备负载跑高导致丢包,而RDS根本就无法接受到数据包,也无法处理。&lt;/p&gt;

&lt;p&gt;但阿里云网络工程师和数据库工程师在各个节点上抓包都没有发现问题,此时服务端侧只能排除.为了验证不是服务端的问题，我们同时还做以下验证:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阿里内网直接访问RDS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个只需要在阿里云ECS安装一个MySQL客户后直接连接阿里云的内外网地址即可,从抓包和使用上来看没有任何问题,也没有发现有TCP不断的重传现象.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;公司网络访问其他自建数据库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;公司直接访问其他数据库也发现了同样的问题,客户端过一段时间后不段的发送&lt;code&gt;[TCP Retransmission]&lt;/code&gt;包,从目前看来网络问题和服务端没有什么关系.&lt;/p&gt;

&lt;h4 id=&#34;2客户端侧排查&#34;&gt;2、客户端侧排查&lt;/h4&gt;

&lt;p&gt;此时,我们更多的焦点还是定位到公司网络方面,和同事一起梳理了对应的公司网络拓扑图，如下:&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;/images/network/1571367817272.png&#34; alt=&#34;1571367817272&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;从拓扑图可以看出,如果问题出现在公司网络,那么会有以下可能. &lt;strong&gt;光纤接收器&lt;/strong&gt;、&lt;strong&gt;防火墙&lt;/strong&gt;、&lt;strong&gt;三层路由交换机&lt;/strong&gt;、&lt;strong&gt;二层交换机&lt;/strong&gt;。所以此时只能使用排除法一个一个来筛选。&lt;/p&gt;

&lt;p&gt;公司本地就有一个MySQL服务,使用Navicat连接操作没有任何问题。&lt;/p&gt;

&lt;p&gt;所以可以排除&lt;strong&gt;二层交换机&lt;/strong&gt;没有问题.&lt;/p&gt;

&lt;p&gt;防火墙是华为的设备,跟华为技术人员沟通，我们可以直接让PC连接到防火墙上网,此时我们有以下情况:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直连防火墙后访问外网数据库有无问题。 (可以定位防火墙和光纤接收器)。&lt;/li&gt;
&lt;li&gt;直连防火墙后访问内网本地数据库有无问题。 (可以定位防火墙和三层路由交换机)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而,从抓包和测试来看,无论是访问外网还是内网数据库都会丢包,客户端会不断的发送重传包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么问题就确定了，就是这台防火墙在作祟,它将数据包丢弃了&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;三解决问题&#34;&gt;三、解决问题&lt;/h2&gt;

&lt;p&gt;我们的防火墙本身是可以抓包的,以下是在防火墙抓的包:&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;/images/network/1571368712632.png&#34; alt=&#34;1571368712632&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;从上面的抓包来看可以得出一下结论:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端和服务端在不停的建立连接&lt;/li&gt;
&lt;li&gt;客户端在服务端之间出现丢包或者乱序。 参考: &lt;a href=&#34;https://www.cnblogs.com/strick/p/6261463.html&#34;&gt;Wireshark网络抓包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;客户端发起TCP三次握手时，seq序列号依然很大,看起来又不像一次TCP连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从防火墙的配置来看，MySQL协议的会话超时时间设置的是6s, 这个时间太小了,以至于客户端或服务端还未来的及发送对应的&lt;code&gt;TCP Keepalive&lt;/code&gt;包,防火墙就将其连接断开，这也就验证了客户端为什么不停的发送重传包和到了超时时间后再建立连接.&lt;/p&gt;

&lt;p&gt;修改对应的参数后，我们在客户端抓包如下:&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;/images/network/1571371078463.png&#34; alt=&#34;1571371078463&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;可以看到服务端或客户端会隔一定的时间发送对应的&lt;code&gt;TCP Keep-Alive&lt;/code&gt;包来保持这个连接，这样在防火墙断开这个连接之前就发送&lt;code&gt;TCP Keep-Alive&lt;/code&gt;包来确定保持这个连接，防火墙也就不会再断开这个TCP连接.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>二进制存储</title>
      <link>/post/bin-store/</link>
      <pubDate>Thu, 06 Jun 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/bin-store/</guid>
      
        <description>&lt;p&gt;这一篇主要讲解内存和寄存器是如何存储数据。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;逻辑电路&lt;/strong&gt;那篇文章中,讲述了如果使用逻辑门来搭建一个加\减法器,也就是说我们可以模拟CPU做加法运算了,但是这还远远不够,计算的结果我们该如何存储呢？ 我们总不能直接丢弃了吧。&lt;/p&gt;
&lt;p&gt;这一篇我就带你来看看如和使用逻辑门来存储一位二进制数据bit,在此基础上在对底层进行抽象看看如何存储多位数据。&lt;/p&gt;
&lt;h2 id=&#34;一反馈电路&#34;&gt;一、反馈电路&lt;/h2&gt;
&lt;p&gt;上述所举的例子都是在特定的输入产生特定的输出,那么有没有一种方式输入即是输出,输出也是输入呢？ 就像下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E5%8F%8D%E9%A6%88.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个电路装置功能是将输入取反然后再将其输出作为输入,我们把这种电路称为振荡器,而这种电路连接的方式叫做反馈.振荡器本身的输出也是在0和1之间不断的变换,如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/clock.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;振荡器从某个状态开始，经过一段时间后又回到初始状态,我们叫做一个循环或者一个周期. 而周期的倒数也就是我们所说的频率,用赫兹来表示。通过我们所说的CPU 2.5GHZ也就是指CPU内部晶体震荡的次数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们将反馈的电路用于一对&lt;code&gt;或非门&lt;/code&gt;看看有会发生什么情况呢？&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;或非门&#34;&gt;或非门&lt;/h4&gt;
&lt;p&gt;或非门的特点是当输入全为0时输出为1,一个输入为1时输出为0.真值表如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们将两个或非门按照如下方式进行连接:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E6%88%96%E9%9D%9E%E9%97%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在初始电路状态下只有左边或非门的输出为1,右边的或非门输出0.  当&lt;code&gt;1号&lt;/code&gt;输入为1时,左边的输出为0,而&lt;code&gt;2号&lt;/code&gt;输入还是0,所以右边的或非门输出为1.此时由于电路反馈的原因，我们无论怎么改变&lt;code&gt;1号&lt;/code&gt;的输入左边或非门的输出都不会发生改变,&lt;strong&gt;永远为0&lt;/strong&gt;. 也就是说我们无论为&lt;code&gt;1号&lt;/code&gt;输入做任何改变都无法改变最终门电路的输出。 这个不觉得很奇怪吗？&lt;/p&gt;
&lt;p&gt;现在，我们将&lt;code&gt;2号&lt;/code&gt;或非门的输入改变为1，此时右边的或非门电路输出永远为0,电路的最终输出也被改变了.  像是我们重置了某种状态让其回到最原始的形态。 而且，我们此时无论对&lt;code&gt;1号&lt;/code&gt;输入做任何改变都无法改变整个门电路的输出结果。&lt;/p&gt;
&lt;p&gt;到目前为止，我们可以总结以上电路的情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1号&lt;/code&gt;输入为1时，门电路输出为1, 电路确定，不会因&lt;code&gt;1号&lt;/code&gt;的输入改变而改变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2号&lt;/code&gt;输入为1时，门电路输出为0, 电路确定，不会因&lt;code&gt;2号&lt;/code&gt;的输入改变而改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上，对于拥有不同的输入却拥有这相同的输出电路组合我们称之为&lt;strong&gt;触发器&lt;/strong&gt;. 触发器可以记住某种状态信息，比如，当我们知道上述的门电路输出为1时，我们也就是知道最后一次输入为1的是&lt;code&gt;1号&lt;/code&gt;电路。&lt;/p&gt;
&lt;p&gt;触发器的种类繁多，下面我们看看常用来存储的触发器。&lt;/p&gt;
&lt;h2 id=&#34;二触发器&#34;&gt;二、触发器&lt;/h2&gt;
&lt;h4 id=&#34;r-s-触发器&#34;&gt;R-S 触发器&lt;/h4&gt;
&lt;p&gt;基本RS触发器又称为SR锁存器，是触发器中最简单的一种，也是各种其他类型触发器的基本组成部分. 由两个&lt;strong&gt;与非门&lt;/strong&gt;或者&lt;strong&gt;或非门&lt;/strong&gt;的输入端输出端交叉耦合或者首尾相接组成，即可以构成一个基本的RS触发器。&lt;/p&gt;
&lt;p&gt;S(Set)表示设置,为高电位;R(reset)表示重置,为低电位。 其输出也包含两个状态,Q和（Q反）。当Set置为1时，Q输出为1，当R置为1时，Q输出为0. 当R和S均为0时，输出Q和Q反保持上一个状态不变。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;R&lt;/th&gt;
&lt;th&gt;Q&lt;/th&gt;
&lt;th&gt;Q反&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;Q~&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;禁止&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;R-S触发器的连接如下:
&lt;img src=&#34;/images/circuit/rs.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;d触发器&#34;&gt;D触发器&lt;/h4&gt;
&lt;p&gt;D触发器是在R-S触发器基础上构建出来的,它拥有一个数据端输入位、一个时钟端输入。当时钟端电信号由0转1时，输出的值和输入的值相等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;D&lt;/th&gt;
&lt;th&gt;Ck&lt;/th&gt;
&lt;th&gt;Q&lt;/th&gt;
&lt;th&gt;Q~&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;Q~&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/D%E8%A7%A6%E5%8F%91%E5%99%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由此，我们便使用D触发器锁住了一位bit位二进制数.为了便于理解，我们将&lt;code&gt;时钟&lt;/code&gt;可以理解为允许写入线,将&lt;code&gt;数据端&lt;/code&gt;理解为允许写入的数据。并将其封装在一个盒子中,拥有此盒子便可以向盒子读写1bit的数据和读取数据。其抽象的结构便如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E8%A7%A6%E5%8F%91%E5%99%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;很容易想到，如果我们把8个这样的设备组合在一起也就成了一个可以保存8位二进制数的存储元件,那64位呢？也就是一个可以存储64个二进制位的存储器,像这样的器件我们也可以叫做寄存器。&lt;/p&gt;
&lt;p&gt;下图是一个可以存储8位的触发器示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/8%E4%BD%8D%E8%A7%A6%E5%8F%91%E5%99%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三寄存器和内存&#34;&gt;三、寄存器和内存&lt;/h2&gt;
&lt;p&gt;寄存器的设计相对于内存还是比较简单一点，我们只需要讲对应的数据流连接到对应的接口(引脚)上,当写信号到来时,我们把数据一一灌入到对应的锁存器里就行.但是内存并非如此,我们知道内存通常是我们给定一个地址然后对这个地址上的数据进行操作,这里有一个地址的概念.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相对于内存来说,寄存器的读写操作是通过寄存器文件中每个寄存器的ID来进行读写操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;寄存器&#34;&gt;寄存器&lt;/h4&gt;
&lt;p&gt;所以我们将上述的8位所存储进行抽象成为一个8位寄存器:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E5%AF%84%E5%AD%98%E5%99%A8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;内存&#34;&gt;内存&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;内存的最大一个特点就是我们给定一个地址,然后可以在该地址上读取或写入一个数.&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;四总结&#34;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;计算机底层对用来说隐藏了很多抽象细节,也是这些我们看不到的细节让我们觉得计算机一直是个谜,这里存储器或者寄存器的设计要比这个麻烦的多,我们不必追究其底层实现的每个细节,其需要了解其底层的核心原理即可。&lt;/p&gt;
&lt;p&gt;这里假设我们实现了一个64位的寄存器和多位的存储器(内存)。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Docker所依赖的Linux内核技术</title>
      <link>/post/docker-linux/</link>
      <pubDate>Fri, 10 May 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/docker-linux/</guid>
      
        <description>&lt;p&gt;上一篇文章讲到Docker本质上还是一个进程，它的隔离主要依赖于Linux内核的Namespace机制，这篇文章就带你从进程创建到Namespace机制进行简单剖析。&lt;/p&gt;
&lt;h2 id=&#34;一namespace简介&#34;&gt;一、Namespace简介&lt;/h2&gt;
&lt;p&gt;当前，Linux内核共实现了六种不同类型的Namespaces(较新版本的内核添加了Cgroups namespace)。每个Namespace的功能是将一个特定的全局系统资源包装在一起, 这让每个进程错误的以为自己都拥有独立的全局资源。Namespace的总体目标是支持容器技术的实现，为每个或每一组进程提供一种假象让其错误的认为自己就是操作系统的唯一进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux内核的六种Namespace:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;分类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;系统调用参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;内核版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Mount namespace&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWNS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Linux 2.4.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;UTS namespaces&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWUTS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Linux 2.6.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;IPC namespaces&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWIPC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Linux 2.6.19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;PID namespaces&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWPID&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Linux 2.6.24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;NETWORK namespaces&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWNET&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;始于Linux 2.6.24 完成于 Linux 2.6.29&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;User namesapces&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLONE_NEWUSER&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;始于 Linux 2.6.23 完成于 Linux 3.8)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从实现时间上来看，Redhat6系列天然不支持，建议直接使用Redhat7系列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mount namespace:&lt;/strong&gt; 隔离一组进程文件系统挂载点集合，从而实现不同Namespace中的进程看到的文件系统不同。 mount() 和 umount() 系统调用将不在全局操作系统上执行，而是在于调用进程相关联的Namespace中操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTS namespaces:&lt;/strong&gt; 隔离一个系统的身份标识符。分别通过sethostname() 和 setdomainname() 系统调用进程设置，此Namespac允许每个容器中拥有自己的主机名等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPC namespaces:&lt;/strong&gt; 进程间通信隔离，也就是Systme V IPC和POSIX message queues对象，每个IPC Namespace都拥有自己一套的System V IPC标识符和自己的POSIX消息队列系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PID namespaces:&lt;/strong&gt; 隔离进程的PID号，换句话说，不同的Namespace中可以拥有相同的PID号。一个好处是每个进程可以在宿主机中迁移并保持这个PID不变。 PID Namespace也允许每个容器中拥有自己的Init，管理系统的初始化和进程回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NETWORK namespaces:&lt;/strong&gt; 隔离网络相关资源，每个Network Namespace中都拥有独立的网络设备、IP地址、ip路由表、/proc/net目录，端口号等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User namesapces:&lt;/strong&gt; 隔离进程的用户、用户组。换句话说，运行一个User Namespace中进程的用户或者用户组可以和操作系统中的用户不同。 比如在操作系统中以非==root==用户运行，而在User Namesapce中以==root==用户运行。&lt;/p&gt;
&lt;p&gt;从Linux内核3.8开始，用户可以在/proc/[pid]/ns目录下看到指向不同的Namespace的文件。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ls -l /proc/self/ns/
total 0
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 ipc -&amp;gt; ipc:[4026531839]
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 mnt -&amp;gt; mnt:[4026531840]
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 net -&amp;gt; net:[4026531956]
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 pid -&amp;gt; pid:[4026531836]
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 user -&amp;gt; user:[4026531837]
lrwxrwxrwx. 1 root root 0 Mar 26 11:34 uts -&amp;gt; uts:[4026531838]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上，内核提供了上述六种Namespace功能，但这又是如何与进程产生关联的呢？ 这主要是使用Linux提供的系统调用功能。&lt;/p&gt;
&lt;h2 id=&#34;二linux的系统调用&#34;&gt;二、Linux的系统调用&lt;/h2&gt;
&lt;p&gt;Linux内核中设置了一组用于实现各种系统功能的子程序，被称之为系统调用。用户可以在自己的应用程序中引用对应的头文件来调用他们。 从某种角度来看，系统调用非常类似于普通的函数，区别在于系统调用运行在内核态，而用户自己的函数运行在用户态。 我通常跟愿意称之为内核提供的API接口。&lt;/p&gt;
&lt;p&gt;而Namespace机制也就是通过在创建进程时(系统调用)通过传递不同的参数实现。实现Namespace功能的系统调用主要包括三个，分别是&lt;code&gt;clone()&lt;/code&gt;、 &lt;code&gt;setns()&lt;/code&gt;、 &lt;code&gt;unshare()&lt;/code&gt;, 当然还包括/proc目录下的部分文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone(): 实现进程的系统调用，用来创建一个新的进程，并可以通过传递不同参数达到隔离。&lt;/li&gt;
&lt;li&gt;unshare(): 是某个进程脱离某个Namespace。&lt;/li&gt;
&lt;li&gt;setns(): 把某个进程加入某个Namespace。
接下来，以==clone==系统调用为列来创建一个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;clone系统调用&#34;&gt;Clone()系统调用&lt;/h4&gt;
&lt;p&gt;在Linux中，创建一个进程的一个简单方式就是Clone() 函数，函数的基本形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    int clone(int (*fn)(void *), void *child_stack,  int flags, void *arg ) ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;clone()&lt;/code&gt;系统调用是传统Unix系统调用fork() 的一种更通用的实现方式。可以通过传递不同的flags参数实现多种功能。下面来看看&lt;code&gt;clone()&lt;/code&gt;函数传递的参数功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fn: 指定新进程要执行的函数，当这个函数返回时表示子进程结束。返回值表示子进程的退出状态码。&lt;/li&gt;
&lt;li&gt;arg: 像指定的函数中传递的参数。&lt;/li&gt;
&lt;li&gt;child_stack: 指定子进程所使用的栈地址。&lt;/li&gt;
&lt;li&gt;flags: 子进程结束后发送给父进程的终止信号，通常为SIGCHLD信号。也可以和CLONE_*开头的各种标志位。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于&lt;code&gt;clone()&lt;/code&gt;系统调用更多的内容请参考：&lt;a href=&#34;http://man7.org/linux/man-pages/man2/clone.2.html&#34;&gt;http://man7.org/linux/man-pages/man2/clone.2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来看一个关于Clone的案例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];

char* const container_args[] = {
            &amp;quot;/bin/bash&amp;quot;,
            NULL
};

int container_main(void* arg)
{
            printf(&amp;quot;Container - inside the container!\n&amp;quot;);
            /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */
            execv(container_args[0], container_args);
            printf(&amp;quot;Something&#39;s wrong!\n&amp;quot;);
            return 1;
}

int main()
{
            printf(&amp;quot;Parent - start a container!\n&amp;quot;);
            /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */
            int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);
            /* 等待子进程结束 */
            waitpid(container_pid, NULL, 0);
            printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
            return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个示例表示使用&lt;code&gt;clone()&lt;/code&gt;创建一个新的进程，并在子进程中执行&lt;strong&gt;bin/bash&lt;/strong&gt;,即:启动一个新的Shell程序,等待用户进行交互. 当子进程退出时，父进程调用SIGCHLD信号进行收尾工作。
接下来我们执行这个程序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/clone$ echo $$
22099   #显示当前shell进程的pid号。
busyboy@busyboy:~/docker/clone$ ./clone.out   # 执行对应的程序。
Parent - start a container!
child Process id is 26208
Container - inside the container!
busyboy@busyboy:~/docker/clone$ echo $$
26208    # 在此查看当前的pid号，可以发现已经和之前的不一样了，说明已经在新的进程中运行。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，我们可以使用&lt;code&gt;pstree -p&lt;/code&gt;命令来查看进程树，所得到的结果也是一样的。&lt;/p&gt;
&lt;p&gt;上面的程序简单的描述了&lt;code&gt;clone()&lt;/code&gt;系统调用的使用方法，而Namespace也是通过给子进程传递不同的参数实现不同级别的隔离。接下来我们看看不同级别的Namespace。&lt;/p&gt;
&lt;h2 id=&#34;三linux的namespace&#34;&gt;三、Linux的Namespace&lt;/h2&gt;
&lt;h4 id=&#34;uts-namespace&#34;&gt;UTS Namespace&lt;/h4&gt;
&lt;p&gt;UTS namespace 提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。&lt;/p&gt;
&lt;p&gt;下面我们通过代码来感受一下 UTS 隔离的效果，整个程序还是对上述&lt;code&gt;clone()&lt;/code&gt; 系统调用程序的修改；代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

/* 定义一个给 clone 用的栈，栈大小1M */
#define STACK_SIZE (1024 * 1024)
static char container_stack[STACK_SIZE];

char *const container_args[] = {
            &amp;quot;/bin/bash&amp;quot;,
                NULL};

int container_main(void *arg)
{
          printf(&amp;quot;Container - inside the container!\n&amp;quot;);
          sethostname(&amp;quot;container&amp;quot;, 10); // 设置主机名
          /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */
          execv(container_args[0], container_args);
          printf(&amp;quot;Something&#39;s wrong!\n&amp;quot;);
          return 1;
}

int main()
{
          printf(&amp;quot;Parent - start a container!\n&amp;quot;);
          /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */
          int container_pid = clone(container_main, container_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);
          /* 等待子进程结束 */
          waitpid(container_pid, NULL, 0);
          printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
          return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个程序主要修改了两个部分，第一个是在进行&lt;code&gt;clone()&lt;/code&gt;系统调用时传递了CLONE_NEWUTS这个参数，第二个是使用&lt;code&gt;sethostname()&lt;/code&gt;系统调用设置主机名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/uts$ sudo ./uts.out
Parent - start a container!
Container - inside the container!
root@container:~/docker/uts# hostname
container
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;ipc-namespace&#34;&gt;IPC Namespace&lt;/h4&gt;
&lt;p&gt;IPC即进程间通信，是指在不同的进程之间传播和信息交换。IPC的方式通常有管道、消息队列、信号量、共享内存、Socket、Streams等。为了让同一个Namespace下的进程相互通信，所以，我们也需要把IPC给隔离出来。对于每个IPC来说，他们都有自己的System V IPC和POSIX message queues,并且对其他的namespace不可见。
在Linux下，我们想要和ipc打交道通常需要使用一下两个命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ipcs: 查看IPC(共享内存、消息队列和信号量)的信息&lt;/li&gt;
&lt;li&gt;ipcmk: 创建IPC(共享内存、消息队列和信号量)的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注：由于代码都是在上层基础上做改动，这个只写出修改的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;int container_pid = clone(container_main, container_stack+STACK_SIZE,
            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先，我们在shell中使用ipcmk -Q 创建一个全局的message queue。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/ipc$ ipcmk -Q
Message queue id: 0
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查看&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/ipc$ ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0xa33c2bdb 0          busyboy    644        0            0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，我们在==clone==中加上CLONE_NEWIPC 这个系统调用，我们就就看不到这个ipc：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@container:~/docker/ipc# ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，刚才创建的IPC已经被隔离了。&lt;/p&gt;
&lt;h4 id=&#34;pid-namespace&#34;&gt;PID Namespace&lt;/h4&gt;
&lt;p&gt;PID namespace 隔离非常实用，它对进程 PID 重新标号，即可以实现两个不同 namespace 下的进程可以有一个相同的PID。内核为每个PID namespace维护一个树状结构，最顶层的是系统初始化时所创建，我们称之为root namespace。他所创建新的pid namespace就称之为child namespace. 通过这种方式，不同的pid namespace会形成一个树状的等级体系，在这个树中，父namespace可以对子namespace产生影响，而反过来则不行。
我们来修改上面的程序:&lt;/p&gt;
&lt;p&gt;添加CLONE_NEWPID 这个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int container_pid = clone(container_main, container_stack + STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | SIGCHLD, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看子进程中答应对应的pid&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;Container id: [%d] - inside the container!\n&amp;quot;,getpid()); //打印pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果如下： 可以看到子进程的pid已经是1了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/pid$ sudo ./pid.out
Parent - start a container!
Container id: [1] - inside the container!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还记得我们演示==clone==系统调用那个最初始的例子吗, 那是有当前pid namespace内核分配的，而在实现了新的pid namespace之后，内核会将第一个进程分配为pid为1,它管理这这个namespace下的进程生命周期。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/pid$ echo  $$
27028
busyboy@busyboy:~/docker/pid$ sudo ./pid.out
Parent - start a container!
Container id: [1] - inside the container!
root@container:~/docker/pid# echo $$
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里讲一讲pid为1的进程特殊作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当我们新建一个 PID namespace 时，默认启动的进程 PID 为 1。我们知道，在传统的 UNIX 系统中，PID 为 1 的进程是 init，地位非常特殊。他作为所有进程的父进程，维护一张进程表，不断检查进程的状态，一旦有某个子进程因为程序错误成为了“孤儿”进程，init 就会负责回收资源并结束这个子进程。所以在你要实现的容器中，启动的第一个进程也需要实现类似 init 的功能，维护所有后续启动进程的运行状态。这样的设计非常有利于系统资源的监控和回收。Docker启动时，第一个进程也是这样的，负责子进程的资源回收。&lt;/li&gt;
&lt;li&gt;PID namespace 中的 init 进程如此特殊，自然内核也为他赋予了特权——信号屏蔽。即同一个Namespace下的进程发送给它的信号都会被屏蔽，这个功能防止init进程被误杀。那么其父节点 PID namespace 中的进程发送同样的信号会被忽略吗？父节点中的进程发送的信号，如果不是 SIGKILL（销毁进程）或 SIGSTOP（暂停进程）也会被忽略。但如果发送 SIGKILL 或 SIGSTOP，子节点的 init 会强制执行（无法通过代码捕捉进行特殊处理），也就是说父节点中的进程有权终止子节点中的进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时,进程已经被隔离了，如果我们执行ps、top命令是不是就看不到宿主机上的进程了呢，但事实真的如此吗？&lt;/p&gt;
&lt;p&gt;这是因为像ps、top这样的命令会去读内核的/proc文件系统，但此时我们并没有对文件系统做隔离，所以还是会显示操作系统的信息。我们不妨在手动挂载下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@container:~/docker/pid# mount -t proc proc /proc/
root@container:~/docker/pid# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.2  10232  4996 pts/1    S    07:47   0:00 /bin/bash
root        14  0.0  0.1  18976  3096 pts/1    R+   08:11   0:00 ps aux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到实际的 PID namespace 就只有两个进程在运行。
注意：因为此时我们没有进行 mount namespace 的隔离，所以这一步操作实际上已经影响了 root namespace 的文件系统，当你退出新建的 PID namespace 以后操作系统的/proc文件系统已经损坏了，再次执行&lt;code&gt;mount -t proc proc /proc&lt;/code&gt;就可以修复错误。&lt;/p&gt;
&lt;h4 id=&#34;mount-namespace&#34;&gt;Mount Namespace&lt;/h4&gt;
&lt;p&gt;Mount Namespace隔离的是文件系统的挂载点，也就是说不同的namespace下的进程看到的文件系统结构不同。在Namespace内可以同mount和umount系统调用来修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clone 调用部分处修改，添加一个CLONE_NEWNS参数
int container_pid = clone(container_main, container_stack + STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
# 添加头文件
#include &amp;lt;stdlib.h&amp;gt;
# 执行系统调用
system(&amp;quot;mount -t proc proc /proc&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时我们在执行ps命令，可以只有两个进程，而且/proc文件也干净了很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@container:/home/busyboy/docker/mount# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1   9028  3668 pts/0    S    08:37   0:00 /bin/bash
root        15  0.0  0.1  18976  3068 pts/0    R+   08:38   0:00 ps aux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在通过CLONE_NEWNS创建新的mount namespace后，父进程会把自己的文件结构复制给子进程。由于开启了隔离，子进程的所有mount操作都影响自身的文件系统，不会对外界产生任何影响。&lt;/p&gt;
&lt;p&gt;你可能会问，我们是不是还有别的一些文件系统也需要这样mount?  == 是的。&lt;/p&gt;
&lt;p&gt;你可以还会问，如果我插入一个新的磁盘，想让每个进程都可以看到这个磁盘，是不是要在每个mount namespace中都执行一遍挂载操作?。== 并不是。&lt;/p&gt;
&lt;p&gt;了解Docker的朋友应该知道，这和Docker镜像中太不一样。Docker可是提供了一整套的rootfs。
接下来，我们使用chroot的工具，来模仿一个完整的Docker rootfs。
假设,我们现在有一个/opt/test目录，想让其作为/bin/bash进程的根目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@busyboy:/home/busyboy/docker/mount# mkdir /opt/test
root@busyboy:/home/busyboy/docker/mount# mkdir -p /opt/test/{bin,lib64,lib}
root@busyboy:/opt/test/lib# mkdir x86_64-linux-gnu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把对应的目录copy到test目录对应的bin目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@busyboy:/home/busyboy/docker/mount# cp -v /bin/{bash,ls} /opt/test/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来把命令所依赖的so文件和各种库文件copy到对应的lib目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@busyboy:/home/busyboy/docker/mount#  list=&amp;quot;$(ldd /bin/ls | egrep -o &#39;/lib.*\.[0-9]&#39;)&amp;quot;
root@busyboy:/opt/test/lib# for i in $list; do cp -v &amp;quot;$i&amp;quot; &amp;quot;${T}${i}&amp;quot;; done
root@busyboy:/opt/test/lib# cp /lib/x86_64-linux-gnu/libtinfo.so.6 /opt/test/lib/x86_64-linux-gnu/

busyboy@busyboy:/opt/test$ sudo chroot /opt/test/ /bin/bash
[sudo] password for busyboy:
bash-4.4# ls /
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时，如果你执行&lt;code&gt;ls -l&lt;/code&gt;就会发现，它返回的是/opt/test目录下的内容，而不是宿主机中的内容。
实际上，Mount Namespace正是基于对chroot的不断改良才被发明出来的。&lt;/p&gt;
&lt;h4 id=&#34;user-namespace&#34;&gt;User Namespace&lt;/h4&gt;
&lt;p&gt;User Namespace主要隔离了安全相关的标识符和属性，包括用户ID、用户组等。说的通俗一点，一个普通用户的进程通过传递CLONE_NEWUSER 参数，Namespace内部看到的用户uid和gid已经和外部不同了。其默认为65534.(其设置定义在/proc/sys/kernel/overflowuid)
要把容器中的uid和系统中的uid关联起来，需要修改&lt;code&gt;/proc/pid/uid_map&lt;/code&gt;和&lt;code&gt;/proc/pid/gid_map&lt;/code&gt;这两个文件，文件格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~$ cat /proc/self/uid_map
         0            0            4294967295
      ID-inside-ns   ID-outside-ns   length
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;第一个字段ID-inside-ns表示容器内部显示的UID或者GID.
第二个字段ID-outside-ns表示容器外部映射的真实UID或者GID.
第三个字段表示映射的范围，一般填1，表示一一对应。如果该值大于1，则按顺序建立一一映射。
代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define _GNU_SOURCE
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;sys/capability.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

static char container_stack[STACK_SIZE];
char *const container_args[] = {
    &amp;quot;/bin/bash&amp;quot;,
    NULL};

int pipefd[2];

void set_map(char *file, int inside_id, int outside_id, int len)
{
  FILE *mapfd = fopen(file, &amp;quot;w&amp;quot;);
  if (NULL == mapfd)
  {
    perror(&amp;quot;open file error&amp;quot;);
    return;
  }
  fprintf(mapfd, &amp;quot;%d %d %d&amp;quot;, inside_id, outside_id, len);
  fclose(mapfd);
}

void set_uid_map(pid_t pid, int inside_id, int outside_id, int len)
{
  char file[256];
  sprintf(file, &amp;quot;/proc/%d/uid_map&amp;quot;, pid);
  set_map(file, inside_id, outside_id, len);
}

void set_gid_map(pid_t pid, int inside_id, int outside_id, int len)
{
  char file[256];
  sprintf(file, &amp;quot;/proc/%d/gid_map&amp;quot;, pid);
  set_map(file, inside_id, outside_id, len);
}

int container_main(void *arg)
{

  printf(&amp;quot;Container [%5d] - inside the container!\n&amp;quot;, getpid());

  printf(&amp;quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&amp;quot;,
         (long)geteuid(), (long)getegid(), (long)getuid(), (long)getgid());

  /* 等待父进程通知后再往下执行（进程间的同步） */
  char ch;
  close(pipefd[1]);
  read(pipefd[0], &amp;amp;ch, 1);

  printf(&amp;quot;Container [%5d] - setup hostname!\n&amp;quot;, getpid());
  //set hostname
  sethostname(&amp;quot;container&amp;quot;, 10);

  //remount &amp;quot;/proc&amp;quot; to make sure the &amp;quot;top&amp;quot; and &amp;quot;ps&amp;quot; show container&#39;s information
  mount(&amp;quot;proc&amp;quot;, &amp;quot;/proc&amp;quot;, &amp;quot;proc&amp;quot;, 0, NULL);

  execv(container_args[0], container_args);
  printf(&amp;quot;Something&#39;s wrong!\n&amp;quot;);
  return 1;
}

int main()
{
  const int gid = getgid(), uid = getuid();

  printf(&amp;quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&amp;quot;,
         (long)geteuid(), (long)getegid(), (long)getuid(), (long)getgid());

  pipe(pipefd);

  printf(&amp;quot;Parent [%5d] - start a container!\n&amp;quot;, getpid());

  int container_pid = clone(container_main, container_stack + STACK_SIZE,
                            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);

  printf(&amp;quot;Parent [%5d] - Container [%5d]!\n&amp;quot;, getpid(), container_pid);

  //To map the uid/gid,
  //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent
  //The file format is
  //   ID-inside-ns   ID-outside-ns   length
  //if no mapping,
  //   the uid will be taken from /proc/sys/kernel/overflowuid
  //   the gid will be taken from /proc/sys/kernel/overflowgid

  set_uid_map(container_pid, 0, uid, 1);
  // 这里组有点问题，gid会发生改变
  set_gid_map(container_pid, 0, gid, 1);

  printf(&amp;quot;Parent [%5d] - user/group mapping done!\n&amp;quot;, getpid());

  /* 通知子进程 */
  close(pipefd[1]);

  waitpid(container_pid, NULL, 0);
  printf(&amp;quot;Parent - container stopped!\n&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以普通用户运行如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;busyboy@busyboy:~/docker/user$ gcc user.c -o user.out
busyboy@busyboy:~/docker/user$ ./user.out
Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000
Parent [ 3212] - start a container!
Parent [ 3212] - Container [ 3213]!
Parent [ 3212] - user/group mapping done!
Container [    1] - inside the container!
Container: eUID = 0;  eGID = 65534, UID=0, GID=65534
Container [    1] - setup hostname!

root@container:~/docker/user# id
uid=0(root) gid=65534(nogroup) groups=65534(nogroup)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，容器里运行的用户id是0，也就是特权用户。但实际在容器外部，/bin/bash是以一个普通用户运行的。 这样就提供高了容器的安全性。&lt;/p&gt;
&lt;p&gt;疑惑: 这里组ID并没有对应映射为1000,而是使用了默认值。查看子进程中对应的gid_map文件，发现这个文件为空，说明并没有写入进去。后续再研究研究。&lt;/p&gt;
&lt;h4 id=&#34;network-namespace&#34;&gt;Network Namespace&lt;/h4&gt;
&lt;p&gt;Network Namespace的主要功能是提供网络资源的隔离，包括网络设备、IPV4和IPV6协议栈、路由表、防火墙、Socket等。一个物理设备只能存在于一个Network Namespace中，但是我们在docker中可以看到每个容器都有一个自己的网卡，这又是怎么回事呢？&lt;/p&gt;
&lt;p&gt;首先，我们先看下图，下图表示Docker在宿主机上的网络示意图。&lt;/p&gt;
&lt;p&gt;上图中，Docker使用了一个私有网段，通常这个网络为172.17.0.0网络，当然这是可以配置的。
当你启动一个Docker容器后，可以是ip link show 或者ip addr show来查看当前宿主机的网络情况。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip link show
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens192: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:f7:17:54 brd ff:ff:ff:ff:ff:ff
3: docker0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:45:bb:fc:c8 brd ff:ff:ff:ff:ff:ff
25: veth6d92449@if24: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether aa:77:c4:08:71:79 brd ff:ff:ff:ff:ff:ff link-netnsid 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上，Docker为一个容器创建了一个新的网卡&lt;strong&gt;veth6d92449@if24&lt;/strong&gt;. 我们以Docker Daemon在启动容器Docker init的过程为例。 Docker Daemon在宿主机上负责创建一个网络虚拟设备(这个虚拟设备有两端)，并通过系统调用将其中的一端绑定在Docker0网桥上，一端连如新创建的Network Namespace中,这也就是我们在每个容器中看到的eth0设备。&lt;/p&gt;
&lt;p&gt;下面我们来模拟这个过程:&lt;/p&gt;
&lt;h6 id=&#34;首先我们使用ip命令创建一个network-namespace并激活里面的lo接口&#34;&gt;首先，我们使用ip命令创建一个Network Namespace,并激活里面的lo接口。&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip netns add ns1
[root@localhost ~]# ip netns exec ns1 ip link set dev lo up
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试lo网卡可用性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip netns exec ns1 ping 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;之后增加一对虚拟网卡并把其中一端放入容器中改名为eth0&#34;&gt;之后增加一对虚拟网卡并把其中一端放入容器中改名为eth0&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip link add veth-ns1 type veth peer name docker1.1 # 创建网卡
[root@localhost ~]# ip link set veth-ns1 netns ns1   #加入到ns1 namespace
[root@localhost ~]# ip netns exec ns1 ip link set dev veth-ns1 name eth0  # 修改名称
[root@localhost ~]# ip netns exec ns1 ifconfig eth0 10.10.1.10/24 up
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，我们看ns1中的网卡&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip netns exec ns1 ifconfig -a
eth0: flags=4099&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu 1500
        inet 10.10.1.10  netmask 255.255.255.0  broadcast 10.10.1.255
        ether ca:38:25:dc:46:df  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;最后分配网桥并设置默认路由&#34;&gt;最后分配网桥并设置默认路由&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;将docker1.1 设置新的网卡&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ifconfig docker1.1 10.10.1.11/24 up
[root@localhost ~]# ip netns exec ns1 ip route add default via 10.10.1.1
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;测试和宿主机的网络连通性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[root@localhost ~]# ip netns exec ns1 ping 192.168.1.80
PING 192.168.1.80 (192.168.1.80) 56(84) bytes of data.
64 bytes from 192.168.1.80: icmp_seq=1 ttl=64 time=0.121 ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到此，主机就可以和一个namespace中的网络通信了；但Docker并没有使用ip命令，而是自己实现了ip命令的一些功能。&lt;/p&gt;
&lt;h2 id=&#34;四总结&#34;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;这篇文章讲解了Linux内核一个重要的功能Namespace技术。 从最开始的Namespace功能介绍、到内核提供的Clone系统调用，再到使用代码实现了每个Namespace功能。不难看出，Docker这个神秘的技术其底层还是一个进程，只是在创建的这个进程的时候我们为其添加了各式各式的参数来实现隔离。&lt;/p&gt;
&lt;p&gt;试想一下，Docker的本质是一个进程，那么就有可能出现代码BUG从而导致这个进程占用了整个操作系统的资源，那又该如何避免这个问题呢？&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Docker 基础</title>
      <link>/post/docker-basic/</link>
      <pubDate>Wed, 01 May 2019 15:43:48 +0800</pubDate>
      
      <guid>/post/docker-basic/</guid>
      
        <description>&lt;p&gt;&lt;!-- raw HTML omitted --&gt;Docker和虚拟机有什么关系和区别？&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;Docker是如何实现隔离的？&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;浅谈docker历史&#34;&gt;浅谈Docker历史&lt;/h2&gt;
&lt;p&gt;2013年我刚进入大学学习技术的时候，在学校的技术社团和老师的谈话中听到最多的莫过于&lt;strong&gt;云计算&lt;/strong&gt;,其中听到最多的专业名词是openstack;那时听着他们说叫做IASS项目,不过随着不断的学习OpenStack慢慢淡出了我们视野，随之而来谈论更多的便是&lt;strong&gt;docker&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在2013PASS的热潮中，dotCloud宣布开源自己的容器项目Docker,在当时容器并不是什么新鲜的东西,并且在之前Cloud Foundry早已实现了&amp;quot;容器&amp;quot;的技术,显然这个决定根本也没有人在乎;但由于Docker独特的&lt;strong&gt;镜像&lt;/strong&gt;技术成为Docker弯道超车的不二法宝,并在段段几个月内,Docker项目就迅速崛起,以至于所有的PASS社区在还没有成为他的竞争对手就直接被宣告出局。&lt;/p&gt;
&lt;p&gt;2013年底，dotCloud公司决定改名为Docker公司,这为日后容器技术圈埋下了伏笔.&lt;/p&gt;
&lt;p&gt;在之后的一段时间里Docker项目一路高歌猛进,一时间，“容器化”取代“pass化”成为基础设施领域最火的关键词,与之而来的便是Docker公司在2014年发布的Swarm项目. 而此时,Docker公司早已开始考虑商业化的途径,毕竟用户始终要部署的还是他们的网站、服务、数据库,这才能够产生真真的商业价值.否则Docker也只是用来启动和暂停的小工具,只是幕后英雄。&lt;/p&gt;
&lt;p&gt;CoreOS是一家基础设施领域的创业公司,在Docker项目不久后就将“容器”概念集成到自己的操作系统中,并在短时间内成为了Docker项目中重要力量,但在Docker宣布“Swarm”项目不久后就分道扬镳了,其原因Swarm可以支持更多机器,并且使用Docker项目的原生API来管理,操作方式简洁明了,也奠定了Docker向平台化方向发展,但这却和CoreOS和核心产品和战略发生冲突。&lt;/p&gt;
&lt;p&gt;在2014到2015年这段时间里,Docker生态圈的发展非常旺盛,围绕着Docker在各个层次和创新的项目层出不穷,此时,Docker收购了只有两个全职开发和维护的Fig项目,并提供出了&lt;strong&gt;容器编排&lt;/strong&gt;的基本概念,这边是大名鼎鼎的&lt;strong&gt;Compose&lt;/strong&gt;项目.一时间,整个基础设施大项目都汇聚在Docker公司周围,但也引起了许多人对Docker公司的决策不满,此时也进入了容器发展史的第二阶段。&lt;/p&gt;
&lt;p&gt;2014年6月,基础设施领域的翘楚Google公司宣布一个名叫&lt;strong&gt;Kubernetes&lt;/strong&gt;的项目诞生,这个项目如同当年Docker一样,再一次改变了容器的市场格局。&lt;/p&gt;
&lt;p&gt;在容器领域,Docker早已是一家独大的话语权,但社区成员早已对此抱怨已久。此时,像Google、Redhat等老牌基础设施领域的玩家们,共同发起了一个名为CNCF的基金会,目的是:以kubernetes为基础,建立一个独立基金会方式运营的平台级社区,并以此来抗衡Docker公司的容器生态圈。&lt;/p&gt;
&lt;p&gt;2017年开始,Docker公司先是将Docker项目的容器运行时部分Containerd捐给CNCF社区,紧接着将Docker项目改名为Moby,然后交给社区自行维护.&lt;/p&gt;
&lt;p&gt;最后Kubernetes凭借这参考Google在容器化基础设施领域多年来实践经验Borg和Omega的特性和社区成员的辛勤努力,并最终在这场竞争中完胜。&lt;/p&gt;
&lt;h2 id=&#34;谈谈进程&#34;&gt;谈谈进程&lt;/h2&gt;
&lt;h4 id=&#34;21-概念&#34;&gt;2.1 概念&lt;/h4&gt;
&lt;p&gt;进程：是指计算机中已运行的程序;在&lt;strong&gt;面向进程设计的系统&lt;/strong&gt;(Linux 2.4一下)中,进程为程序的基本执行实体;在&lt;strong&gt;面向线程设计系统&lt;/strong&gt;中(Linux2.6以上),进程为线程的容器. 其中关于进行的定义也有很多，这里个人比较倾向于这种说法: 进程是具有独立功能的程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位.
从大类划分,可以将进程划分为静态(程序)和运行态(进程):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序：通常为可执行文件,放置在存储媒介中,是数据和指令的结合。&lt;/li&gt;
&lt;li&gt;进程：程序执行时的状态,加载所需要的数据(比如：指令、环境变量)到内存中进行执行计算,操作并给予一个标识符PID(进程ID号)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不妨来看看一个简单的程序运是如何运行的。&lt;/p&gt;
&lt;h4 id=&#34;22-程序如何被运行&#34;&gt;2.2 程序如何被运行&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;假设我们写一个加法的小程序,程序的输入来自于一个文件,计算完成后的结果则输出到另一个文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于操作系统之认识0和1,所以无论什么语言编写的代码最后都会被翻译为机器码,最后才在操作系统中运行起来。&lt;/p&gt;
&lt;p&gt;首先,操作系统将可执行文件加载内存中，并交由CPU进行执行,在执行过程中发现需要从文件中读取数据来源,之后并将输入文件加载到内存中保留一份副本进行待命；同时,操作系统读取到计算加法的指令,这时,就会调用CPU完成加法操作；而CPU与内存协作进行加法计算,又会使用寄存器存放数值、内存堆栈等保留执行命令和变量.就这样CPU、内存、I/O、操作系统等共同协作完成了一次加法运算。&lt;/p&gt;
&lt;p&gt;可能你还是不太理解到底是如何完成加法的,这里你可以不用深究,只需要明白操作系统就像是人的大脑一样,他指挥这CPU、内存、I/O设备协同工作完成一件事件,就像你的大脑一样指挥这你如何如何工作,什么时候用手、什么时候用嘴说话。&lt;/p&gt;
&lt;h4 id=&#34;23-给进程加个套&#34;&gt;2.3 给进程加个套&lt;/h4&gt;
&lt;p&gt;对于进程来说,当被运行起来后,需要为它分配很多&lt;strong&gt;资源&lt;/strong&gt;和&lt;strong&gt;视图&lt;/strong&gt;.视图主要为了描述这个进程,资源主要为了进程内部开销使用.通常一个进程在被启动起来我们要分配：PID、User、系统标识符、netwrok、file system等视图. 在传统的一个系统中运行时,进程所需要的这些视图都是由操作系统进行分配,而且部分视图一旦被其他进程申请后将不能在分配,这也就表明了为什么一个进程监听了操作系统的&lt;strong&gt;80&lt;/strong&gt;端口,如果另一个进程在申请监听&lt;strong&gt;80&lt;/strong&gt;端口将会出现冲突。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;容器的核心功能,就是通过约束这些视图的分配，修改进程运行时的表现形式,限制进程的资源开销，从而为其创建一个他无法逃脱的“边界”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于Docker来说,&lt;strong&gt;Namespace技术&lt;/strong&gt;主要就是修改进程运行时一些视图分配,而&lt;strong&gt;Cgroup&lt;/strong&gt;是限制一个进程资源最大开销。&lt;/p&gt;
&lt;h2 id=&#34;虚拟机vs容器&#34;&gt;虚拟机VS容器&lt;/h2&gt;
&lt;p&gt;既然谈到虚拟机,那就不得不放上官方提供的虚拟机和容器的对比图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/docker/docker-1.png&#34; alt=&#34;虚拟机 VS Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：这是最新的官方图片,之前是在底层的Hypervisor下还有一层Host OS.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从上图对比可以看出,在底层上,Docker和Host OS只是替代了虚拟机的Hypervisor.因此,会有很多人认为Docker就是轻量级的虚拟机,但事实真的如此吗？&lt;/p&gt;
&lt;h3 id=&#34;虚拟机&#34;&gt;虚拟机&lt;/h3&gt;
&lt;p&gt;虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 &amp;ndash;来自【百度百科】&lt;/p&gt;
&lt;p&gt;传统的虚拟化技术是对硬件资源的虚拟化,每台虚拟机都要自己的独立的操作系统,这就意味这你可以在windows的机器里安装Linux虚拟机,而且每个虚拟机拥有独立的二进制库、内核. 也就是这里完全是一片新天地,比较常见的是Hypervisor.&lt;/p&gt;
&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;
&lt;p&gt;容器运行在Linux系统本地并且和其他容器共享主机内核。他是一个独立的进程，不占用任何其他可执行文件内存，足够轻量级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单说不够，我们来简单的做个实验，这里假设你有一个安装好的Docker机器。也可以翻到最后查看安装步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;[root@node2 ~]# docker run -it busybox /bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这表示使用&lt;strong&gt;docker run&lt;/strong&gt;启动一个&lt;strong&gt;busybox&lt;/strong&gt;虚拟机.而&lt;code&gt;-it&lt;/code&gt; 表示在启动这个容器之后为这个容器分配一个终端,并进入交互式模式;&lt;code&gt;/bin/sh&lt;/code&gt; 就表示我们运行容器后要执行的命令,创建一个shell。
此时，我们就进入了在当前容器下的交互shell,可以使用所有的&lt;strong&gt;busybox&lt;/strong&gt;命令,所拥有的环境变量都是当前容器下的.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ # printenv
HOSTNAME=3fc8a0273acb
SHLVL=1
HOME=/root
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，我们执行一下&lt;code&gt;ps&lt;/code&gt;看看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    6 root      0:00 ps
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，&lt;code&gt;ps&lt;/code&gt;命令查看出来的进程和系统的完全不同，此时这个容器就被Docker隔离在一个跟宿主机完全不同的世界中.
其实，这只是操作系统给的障眼法而已,当我们在宿主机上启动一个容器时,其本质也是一个由系统调用产生的进程(clone调用),操作系统还是为其分配一个进程ID号,例如：pid=100. 我们来看看操作系统分配的PID:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@node2 ~]# docker inspect -f &#39;{{.State.Pid}}&#39; 3fc8a0273
22521
[root@node2 ~]# docker top 3fc8a0273
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种机制就是对被隔离应用的进程做了手脚,使得这些进程只能看到重新计算过的进程编号,也就是上述我们在容器里执行&lt;code&gt;ps&lt;/code&gt;看到的结果.
&lt;strong&gt;这种技术也就是Linux的Namespace技术&lt;/strong&gt;,上述我们刚刚看到的pid也就是六大Namespace之一的&lt;strong&gt;PID Namespace&lt;/strong&gt;,除此之外还有&lt;strong&gt;User&lt;/strong&gt;、&lt;strong&gt;UTS&lt;/strong&gt;、&lt;strong&gt;IPC&lt;/strong&gt;、&lt;strong&gt;Network&lt;/strong&gt;、&lt;strong&gt;Mount&lt;/strong&gt;,用于对同一进程上不同的视图进行隔离.&lt;/p&gt;
&lt;p&gt;这也是容器最基本的实现原理,可以看出它本质上还是一个进程,只是比较特殊而已。&lt;/p&gt;
&lt;p&gt;所以,在上面官方提供的虚拟机对比图中,Docker不应该放在最底层,而是和操作系统里的进程一样,由操作系统管理，而Docker本身则对用户启动的进程完成辅助和管理工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/docker/docker-2.png&#34; alt=&#34;虚拟机 VS Docker&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题： 既然操作系统已经为这个sh进程分配了一个进程ID号，可是，我们在Docker内部还是看到了sh的另一个进程ID&lt;strong&gt;1&lt;/strong&gt;. 难道说操作系统可以随意为进程分配ID号，而且我们知道ID号为1一般是init进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;简述docker&#34;&gt;简述Docker&lt;/h2&gt;
&lt;p&gt;Docker是一个开发、部输和运行应用程序的开放平台. Docker允许你将应用程序和基础架构分离以便可以快速的通过Docker交付软件,你可以像管理应用程序一样管理基础架构,并且快速传输、测试、部署你的代码，在开发和部署上明显节约时间。&lt;/p&gt;
&lt;h4 id=&#34;docker平台&#34;&gt;Docker平台&lt;/h4&gt;
&lt;p&gt;从上述可以知道，Docker实质上还是一个进程。 Docker提供包含运行应用程序所有环境的包，我们称之为容器，并且之间相互隔离;而且，这就意味着你可以运行多个容器在同一个主机上. 实质上也是宿主机上运行的多个进程. 而管理这里进程的程序，我们称之为Docker Engine.&lt;/p&gt;
&lt;h4 id=&#34;docker架构&#34;&gt;Docker架构&lt;/h4&gt;
&lt;p&gt;Docker采用客户端-服务端架构. Docker客户端和Docker守护进程通信. 这解决了沉重的构建、运行、部署Docker容器.Docker客户端和守护进程可以运行在同样的系统中，也可以通过客户端连接远端的Docker服务端.他们之间基于Unix的套接字或者网络接口通过REST API进行通信。
&lt;img src=&#34;/images/docker/docker-3.png&#34; alt=&#34;Docker 架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;Docker客户端:
Docker客户端是Docker用户和Docker交互的主要方式，当你使用docker run命令时，客户端基于API接口将这些命令发送到dockerd。此外一个Docker客户可以和多个Docker服务进程进行通信.&lt;/p&gt;
&lt;p&gt;Docker守护进程:
Docker进程监听docker API的请求和管理Docker对象例如: 镜像、容器、网络和卷. 守护进程可以和其他进程进行通信以管理Docker服务.&lt;/p&gt;
&lt;p&gt;Docker registries(Docker仓库):
Docker registries存储Docker镜像. 像Docker Hub和Docker Cloud是公共镜像库并且所有人都可以访问。Docker的默认查找镜像是通过Docker hub.你也可以使用私人的镜像库.&lt;/p&gt;
&lt;p&gt;我们来说一说当执行&lt;code&gt;docker run&lt;/code&gt;时到底发生了什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@10-19-103-109 ~]# docker run -it ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Docker在本地查找镜像,如果本地没有ubuntu镜像,Docker将从你配置的仓库下载，像是手动运行&lt;code&gt;docker pull ubuntu&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Docker创建一个新的容器，这个过程像是手动运行&lt;code&gt;docker container creater&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Docker为容器分配可读写的文件系统，作为最后一层. 这允许运行的容器直接的修改文件或者目录在本地文件系统.&lt;/li&gt;
&lt;li&gt;docker创建一个网络接口连接容器的默认网络，如果没有做任何网络配置.这包括为容器分配ip地址。默认容器可以连接到外部网络通过宿主机的网络。&lt;/li&gt;
&lt;li&gt;启动docker容器并执行/bin/bash,因为容器运行在交互式模式下并占据你的终端.&lt;/li&gt;
&lt;li&gt;使用exit可以退出当前容器，但容器不会被删除，可以重新启动它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;底层技术&#34;&gt;底层技术&lt;/h4&gt;
&lt;p&gt;上面说过，Docker的实现依赖于Linux的Namespace技术，简单描述下他们的功能:&lt;/p&gt;
&lt;h5 id=&#34;namespace&#34;&gt;namespace&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;The pid namespace: Process isolation (PID: Process ID).  进程间隔离&lt;/li&gt;
&lt;li&gt;The net namespace: Managing network interfaces (NET: Networking).  网络隔离&lt;/li&gt;
&lt;li&gt;The ipc namespace: Managing access to IPC resources (IPC: InterProcess Communication).  进程通信隔离&lt;/li&gt;
&lt;li&gt;The mnt namespace: Managing filesystem mount points (MNT: Mount).  文件系统隔离&lt;/li&gt;
&lt;li&gt;The uts namespace: Isolating kernel and version identifiers. (UTS: Unix Timesharing System).  内核和系统唯一信息隔离（如主机名）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;cgroups&#34;&gt;Cgroups&lt;/h5&gt;
&lt;p&gt;Docker引擎依然依赖于linux的另一个技术叫做Cgroups。一个Cgroups限制一个应用程序的资源集合.Cgroups允许Docker引擎共享可用的硬件资源并可以强制限制.例如: 可以限制每个容器的内存使用。&lt;/p&gt;
&lt;h5 id=&#34;union-file-systems&#34;&gt;Union file systems:&lt;/h5&gt;
&lt;p&gt;Union file systems或者UnionFS通过创建层来操作文件系统，而且他们将非常的轻量和快速.Docker引擎使用UnionFS为容器提供构建的块. Docker引擎可以使用多个类似UnionFS文件系统，列如： AUFS, btrfs, vfs, 和DeviceMapper。&lt;/p&gt;
&lt;h5 id=&#34;container-format&#34;&gt;Container format:&lt;/h5&gt;
&lt;p&gt;Docker引擎联合名称空间、Cgroups、和UnionFS来封装叫做一个容器格式。 默认的容器格式叫做：libcontainer. 之后Docker整合其他技术可能支持其他容器格式例如： BSD jails 或 Solaris Zones.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>逻辑电路</title>
      <link>/post/logic-circuit/</link>
      <pubDate>Sat, 27 Apr 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/logic-circuit/</guid>
      
        <description>&lt;h2 id=&#34;一逻辑电路&#34;&gt;一、逻辑电路&lt;/h2&gt;
&lt;p&gt;在数字逻辑电路中，电平的高低有两种状态，我们称之为&lt;strong&gt;高电平&lt;/strong&gt;、&lt;strong&gt;低电平&lt;/strong&gt;。一般规定低电平为0~0.25V,高电平为3.5-5V. 在TTL门电路中，把低电平用数字0表示，把高电平用数字1表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/dianlu.jpg&#34; alt=&#34;dianlu&#34;&gt;&lt;/p&gt;
&lt;p&gt;由此可以看出，高低电频的表示和二进制数字的表示法一样，那么我们就可以使用组合的逻辑电路来实现二进制之间的逻辑计算。&lt;/p&gt;
&lt;h2 id=&#34;二门电路&#34;&gt;二、门电路&lt;/h2&gt;
&lt;p&gt;在数字电路中，所谓的“门”就是只能实现基本逻辑关系的电路。二进制最基本的逻辑关系是&lt;strong&gt;与&lt;/strong&gt;、&lt;strong&gt;或&lt;/strong&gt;、&lt;strong&gt;非&lt;/strong&gt;;对应于电路中来说的逻辑门就是&lt;strong&gt;与门&lt;/strong&gt;、&lt;strong&gt;或&lt;/strong&gt;、&lt;strong&gt;非门&lt;/strong&gt;.逻辑门可以用电阻、电容、二极管、三极管等分立元件组成。也可以将门电路的所有器件以及连接导线制作在同一块半导体基片上、构成&lt;strong&gt;集成逻辑门电路&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我们不讨论基本的&lt;code&gt;电阻&lt;/code&gt;，&lt;code&gt;三极管&lt;/code&gt;等基本元件，详细讨论下三个逻辑门的实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;与门&#34;&gt;与门&lt;/h4&gt;
&lt;p&gt;在数字逻辑中逻辑与表示从输入到输出的&lt;strong&gt;与&lt;/strong&gt;逻辑运算,我们来看一个真值表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;A AND B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当且仅当两个输入的数都为TRUE时,输出才为TRUE;对应逻辑门电路，仅当输入均为高电平(1)时，输出才为高电平。&lt;/p&gt;
&lt;p&gt;对应的逻辑电路图表示如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/and.jpg&#34; alt=&#34;and&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;或门&#34;&gt;或门&lt;/h4&gt;
&lt;p&gt;在数字逻辑中逻辑与表示从输入到输出的&lt;strong&gt;或&lt;/strong&gt;逻辑运算,我们来看一个真值表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;A OR B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只要输入的两个数有一个为TRUE时，输出就为TRUE.对应于逻辑电路,只要两个输出中有一个为高电平,则输出为高电平。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/or.jpg&#34; alt=&#34;or&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;非门&#34;&gt;非门&lt;/h4&gt;
&lt;p&gt;非门也称之为反相器，在数字逻辑中表示从输入到输出的取反操作. 真值表如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入 A&lt;/th&gt;
&lt;th&gt;输出 NOT&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对应于电路中表示输入高电平则输出低电平。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/not.jpg&#34; alt=&#34;not&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三组合逻辑电路&#34;&gt;三、组合逻辑电路&lt;/h2&gt;
&lt;p&gt;上面讲述了最基本的三种组合逻辑电路，我们知道两个数的逻辑运算除了&lt;code&gt;与&lt;/code&gt;、&lt;code&gt;或&lt;/code&gt;、&lt;code&gt;非&lt;/code&gt;还有&lt;code&gt;异或&lt;/code&gt;、&lt;code&gt;或非&lt;/code&gt;等等。他们也有对应的组合逻辑门.如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/all.jpg&#34; alt=&#34;all&#34;&gt;&lt;/p&gt;
&lt;p&gt;这些基本的门电路就是我们计算机硬件端的最基本的“积木”. 就像堆积木一样，我们现在包含十几亿级别的晶体管CPU也是由这样一个一个门电路组合而成的。&lt;/p&gt;
&lt;p&gt;在描述组合逻辑电路前，我们先看一下与非门的真值表,之后再了解下异或门是如何构造的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与非门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与非门的输出结果恰好和与门的结果刚好相反，我们看一下它的真值表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;NAND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;异或门&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道异或是输入相同时为0，输入不同时为1.真值表如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;th&gt;或门&lt;/th&gt;
&lt;th&gt;与非门&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;首先，我们直观上可以看到，或门的输出和我们想要的一样。除了最后一个。与非门的输出也和我们想要的一样除了第一个。所以如果将这两个门的输出在做一次与运算也就得到了我们想要的结果。这便是异或门。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E5%BC%82%E6%88%96%E9%97%A8.jpg&#34; alt=&#34;异或门&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;半加器&#34;&gt;半加器&lt;/h4&gt;
&lt;p&gt;半加器的功能是将两个一位二进制数相加,它有两个输出:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和: 表示这个数的相加之和,用符号&lt;code&gt;S&lt;/code&gt;表示&lt;/li&gt;
&lt;li&gt;进位: 只有两个数为1时才会产生进位。用符号&lt;code&gt;C&lt;/code&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;半加器的真值表如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个最简单的半加器被设计为使用&lt;strong&gt;异或门&lt;/strong&gt;来产生S,一个&lt;strong&gt;与门&lt;/strong&gt;来产生C.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异或门: 相同则为0，不同则为1. 1+1 =》 0 ， 0+0 =》0&lt;/li&gt;
&lt;li&gt;与门: 当输入同时为1时，输出为1.这就可以表示有进位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个半加器的示意图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/half_add.jpg&#34; alt=&#34;half_add&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;全加器&#34;&gt;全加器&lt;/h4&gt;
&lt;p&gt;从半加器可以看出，如果计算两个1位的二进制数字是没有问题的，但是如果一个二进制数有2位、3位就不行了。不能计算的原因也很简单,它只能接受两个输入的数、却无法接受进位数。所以就有一个全加器的元件来解决这个问题了。&lt;/p&gt;
&lt;p&gt;全加器将两个一位二进制数相加，并根据接收到的低位进位信号，输出和、进位输出.全加器的三个输入信号为两个加数A、B以及进位数C. 来看一看真值表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;C (input)&lt;/td&gt;
&lt;td&gt;C(output)&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;全加器的输出和半加器类似，包括高位的进位信号C和本位的和信号S。&lt;/p&gt;
&lt;p&gt;全加器的设计也很简单，实际上可以使用两个半加器加上一个或门即可组合成一个全加器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个半加器和个位的加法一样，得到是否进位X和对应的两个数加完后的结果Y.然后把这个Y和个位的进位信息U在连接到另一个半加器中，就会得到一个是否进位的信号V和对应的加法后的结果W. 这个W便是我们在第二位上留下的结果。 但对于第二位来说也需要判断是否进位，这时只需要将进位信号V和进位信号X进行与运算，便知道是否需要向前进位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样，通过两个半加器和或门，我们就得到一个能够接受进位信号、加数、被加数，这样三个数组成的加法。全加器计算过程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/%E5%85%A8%E5%8A%A0%E5%99%A8.jpg&#34; alt=&#34;全加器&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然有了全加器可以来表示某个位置的加法，那么对于有8位的二进制数我们只需要连接8个就行了。这样也就可以表示8位二进制数相加，也就是一个加法器。不过你可能会发现对于加法后的和的两侧是需要特殊考虑一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个位来说我们不需要一个全加器，半加器就可以完成工作，当然我们也可以将个位的全加器进位输入始终为0.&lt;/li&gt;
&lt;li&gt;最左侧的如果有进位信号就无法保存了，因为它已经超出了当前加法器的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以一个8位的加法器就如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuitim/add.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;CI: 最右侧的进位输入,这里我们将个位的进位输入置为0。&lt;/p&gt;
&lt;p&gt;CO: 最左侧的进位输出是因为可能得到9位数值。&lt;/p&gt;
&lt;p&gt;在C语言中，部分情况下我们计算两个整数相加会得到一个负数,此时你应该知道了为什么了，因为这个加法的结果溢出了。&lt;/p&gt;
&lt;p&gt;加法器有很多种设计方式，可以参考维基百科的设计.&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8&#34;&gt;加法器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;四减法&#34;&gt;四、减法&lt;/h2&gt;
&lt;p&gt;我们知道做一次减法运算其实和一个数加上另一个数的负数是一样的结果，而且计算机中能够表示负数是使用补码进行编码的。补码有一个特性就是可以做算术运算，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;8 + (-3)
   1000
+  1101
  10101 (5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么计算机底层的各种逻辑门是如何做减法运算的呢？毕竟对于逻辑电路来说它只拿到的是一串0 1二进制串,并不知道补码、原码、反码这些概念。 这时候我们需要增设一个开关，来判断到底是做加法还是减法。&lt;/p&gt;
&lt;p&gt;首先，我们需要解决的是正数如何转化为负数。补码表示中,对一个二进制数取反在加一就可以获得这个数的负数。所以加法器中我们需要引用反向器来对各个位取反。对于一个8位二进制数来说我们需要引用8个反相器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事实上我们需要一个即可以做加法、也可以做减法的电路，这里我们引用一个异或门而不是反相器，当取反信号为0时，8个异或门的输入和输出相同，当取反信号为1时，输出结果和输入的数据刚好相反，这个电路也叫作求补器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述的加法器可以改写成如下电路:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/circuit/sub.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图引用了三个&amp;quot;SUB&amp;quot;标识来作为加法还是减法的开关,当SUB为0时,表示加法,所做的事情和上述的8位加法器一样;当SUB为1时,进行减法运算,也就是x + (-y)的行。&lt;/p&gt;
&lt;p&gt;SUB等于1时, B的输入经过求补器得到B的反码，这时在加上CI的进位1便通过这个巧妙的方法得到了B的补码,之后在加上A的输入可得到对应的结果。&lt;/p&gt;
&lt;p&gt;这个需要注意一下，就是我们如何区分计算出来的数是正数还是负数呢？ (这中情况只会发生在减法运算中)当减数B小于被减数时，CO端输出为1代表溢出(即,最后的结果需要减去最高位,或者忽略进位),这时SUB也为1,所以两个数经过异或后为0,此时代表正数。相关CO端输出为0时,代表负数。&lt;/p&gt;
&lt;p&gt;我们来看一个列子:&lt;/p&gt;
&lt;h4 id=&#34;减数小于被减数&#34;&gt;减数小于被减数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt; 3 - 2 = ? ==&amp;gt; 3 + (-2) = ?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一步：求-2的补码，既求-2的绝对值2的原码取反（11111101）再加1得11111110。在上图中就是输入B经过取反再加CI等于11111110。&lt;/p&gt;
&lt;p&gt;第二步：3的补码（00000011）加上-2的补码（11111110）等于100000001。在上图中就是最后进位1等于CO输出（舍去）即可得到00000001。而CO与SUB均为1，经过异或门为0，此时表示正数，舍弃最高位后即可得到正常值。&lt;/p&gt;
&lt;h4 id=&#34;减数大于被减数&#34;&gt;减数大于被减数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;2 - 3 = ? ==&amp;gt; 2 + (-3) = ?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一步：求-3的补码，既求-3的绝对值3的原码取反（11111100）再加1得11111101。在上图中就是输入B经过取反再加CI等于11111101。&lt;/p&gt;
&lt;p&gt;第二步：2的补码（00000010）加上-3的补码（11111101）等于11111111。在上图中就是最后进位0等于CO输出。而SUB为1，两个输入1、0经过异或门得1，最左侧输出为1，表示结果为负数。 所以我们也就区分了11111111是补码表示为-1而不是255.&lt;/p&gt;
&lt;h2 id=&#34;五总结&#34;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;对于CPU来说,最主要的功能就是计算和存储,计算我们通常用ALU来实现,存储也就是我们常说的寄存器。这个文档我简单介绍了ALU中关于加减法的设计,后续我们将介绍关于存储的设计和实现。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>数字基础</title>
      <link>/post/number-basic/</link>
      <pubDate>Sun, 21 Apr 2019 16:01:23 +0800</pubDate>
      
      <guid>/post/number-basic/</guid>
      
        <description>&lt;p&gt;计算机基础之数字的表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.我们生活中常用的数字如何在计算机中使用二进制表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.这些数如何做数字运算。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一常用进制&#34;&gt;一、常用进制&lt;/h2&gt;
&lt;p&gt;对于习惯使用十个手指头的人类来说，早已习惯使用数字1~10来表示我们生活的数字。 我们也称之为十进制数。&lt;/p&gt;
&lt;p&gt;但现在使用过计算机的人来说都知道计算机底层采用的都是二进制数来表示，这是由于依赖于底层电器信号的限制我们只能模拟出低电频和(0)和高电频(1)的信号,自然使用数字&lt;strong&gt;0&lt;/strong&gt;和&lt;strong&gt;1&lt;/strong&gt;表示最为合适. 但这种表示方法对于人来说不易读而且表示冗长;所以,向上又使用了十六进制来表示，使其变得易读。&lt;/p&gt;
&lt;h4 id=&#34;二进制&#34;&gt;二进制&lt;/h4&gt;
&lt;p&gt;二进制，也就是由&lt;strong&gt;0&lt;/strong&gt;和&lt;strong&gt;1&lt;/strong&gt;组成,用来表示一个十进制&lt;strong&gt;5&lt;/strong&gt;数如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0000 0101
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;二进制数是可以计算的,也可以做逻辑运算,如我们计算一个十进制&lt;strong&gt;5&lt;/strong&gt;加&lt;strong&gt;3&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  0000 0101
+ 0000 0011    #逢二进一
= 0000 1000
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;十进制&#34;&gt;十进制&lt;/h4&gt;
&lt;p&gt;这个掰一掰手指就知道了,就不多说了。&lt;/p&gt;
&lt;h4 id=&#34;十六进制&#34;&gt;十六进制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;十六进制&lt;/strong&gt; 在数学上是一种逢16进1的进位制。用数字0~9和字母A~F表示。&amp;mdash;&amp;ndash; 百度百科&lt;/p&gt;
&lt;p&gt;十六进制的转换也很简单,介绍下二进制和十进制分别转换为16进制。&lt;/p&gt;
&lt;p&gt;二进制数中每四位组成一个十六进制数，如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  0011 1011 0111 1110
     3   B     7    E
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;十进制转十六进制只要除十六取模，和十进制转二进制类似:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4877÷16=304....13(D)
304÷16=19....0
19÷16=1....3
1÷16=0....1
---------------
130D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在C语言中，以&lt;code&gt;0x&lt;/code&gt;或者&lt;code&gt;0X&lt;/code&gt;开头的数字常量被认为是十六进制的值。&lt;/p&gt;
&lt;h2 id=&#34;二数字编码&#34;&gt;二、数字编码&lt;/h2&gt;
&lt;p&gt;我们知道现在计算机普遍使用二进制来表示，这是因为二进制能够工作的更好。对于二进制数来说，单独的讲某一个位没有太多的意义，但是可以将多个位组合起来，再加上某种解释，就可以用来表示我们日常生活中常用的数字。 计算机中常用表示的数又分为&lt;strong&gt;有符号数&lt;/strong&gt;、&lt;strong&gt;无符号数&lt;/strong&gt;和&lt;strong&gt;浮点数&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;无符号&#34;&gt;无符号&lt;/h4&gt;
&lt;p&gt;无符号表示大于或者等于0的数字，是基于传统的二进制表示法进行编码。&lt;/p&gt;
&lt;p&gt;对于一个十进制数来说,如果我们想表示&lt;code&gt;999&lt;/code&gt;这个数，我们也可以写成&lt;code&gt;9*10^2+9*10^1+9*10^0&lt;/code&gt;.对于用二进制来表示表示就更简单了,二进制的每一个位的取值只有两种情况&lt;strong&gt;0&lt;/strong&gt;或者&lt;strong&gt;1&lt;/strong&gt;. 对于一个8位的二进制&lt;strong&gt;10110011&lt;/strong&gt;数表示如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1*2^7+0*2^6+1*2^5+1*2^4+0*2^3+0*2^2+1*2^1+1*2^0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;$$
\sum_{}^{i}*{2^i}
$$&lt;/p&gt;
&lt;p&gt;如上，该数字表示十进制数为&lt;strong&gt;179&lt;/strong&gt;，对于&lt;strong&gt;8&lt;/strong&gt;位的二进制数我们能够表示的范围为0(00000000)~255(11111111).&lt;/p&gt;
&lt;p&gt;无符号的二进制数表示一个很重要的特性，也就是对于任何介于0~2^w-1 之间的数值都有一个唯一w为的值编码。&lt;/p&gt;
&lt;h4 id=&#34;有符号数&#34;&gt;有符号数&lt;/h4&gt;
&lt;p&gt;有符号数表示可以为正或者为负的数字，通常采用&lt;strong&gt;补码&lt;/strong&gt;进行编码。 负数是有符号的数值,对于负数来说，我们最难的就是如何表示它的负号.先来看看什么是&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原码是计算机中数字的二进制定点表示法。数码序列中最高位表示符号位，符号0表示正数，符号1表示负数;其余位表示数值的大小。这样我们使用一个符号位的引用就可以表示正数、负数。对于一个8位二进制数来说，能够表示的范围就是-128(1000 0000)~127(0111 1111)。 但对于原码表示有一个致命的缺点，就是不能参加运算。例如：-1(1000 0001) + 1(0000 0001) = 0(1000 0010) 这个二进制数的实际数值是-2.这显然不对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个数是正数，那么这个数的反码就是它本身。 负数的反码是在原码的基础上，符号位不变，数值位按位取反。这样对于上述-1+1等于-2的问题就解决了。0001 + 1110(-1的反码) = 1111(反码) 转换到对应的数为-0. 但这又带来了一个问题.即0这个数有两种表示法+0和-0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;补码的表示也分为两种，正数的补码是其原码本身，负数的补码是在其反码基础上再加1。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;【+7】补码 = 0000 0111&lt;/p&gt;
&lt;p&gt;【-7】 补码 = 1111 1001&lt;/p&gt;
&lt;p&gt;1 0000  0000&lt;/p&gt;
&lt;p&gt;我们使用补码来计算时，如果丢弃最高位对的进位，正负相加的确是为0的。&lt;/p&gt;
&lt;p&gt;至此，我们可以使用补码来表示我们生活中常用的正数、负数；当然，这是我们丢弃了最高位的代价来换取的。&lt;/p&gt;
&lt;h4 id=&#34;定点数&#34;&gt;定点数&lt;/h4&gt;
&lt;p&gt;从名字来看，我们直观上可以理解为小数点为定点。当然定点数也是用来表示小数的，采用的是BCD码来编码。BCD码将0~9中的每个数用4位二进制数来表示，这样对于32位就可以表示8个数字，表示的数字范围也就是0~999999.99之间的1亿个实数。&lt;/p&gt;
&lt;p&gt;BCD编码也有很多用途，比如银行、超市这种需要用到小数记金额的情况就很合适，但是如果表示很小、或者很大的数就不是很合适了，比如地球到太阳的距离，一个氢原子的半径等等。而且这样编码非常浪费，对于32位整数我们可以表示将近40亿个数字，而BCD编码的数字只能表示1亿个数字。&lt;/p&gt;
&lt;h4 id=&#34;浮点数&#34;&gt;浮点数&lt;/h4&gt;
&lt;p&gt;上面讨论了使用补码表示负数、正数。但是对于浮点数来说补码就无能为力了。 计算机中另一种表示小数的方法是采用了类似于科学计数法的方式来表示浮点数(还有一种方式叫做定点格式)。这个制定的规则由美国电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers）制定的.浮点数的标准定义了两种基本的格式：以4个字节表示的单精度和以8个字节表示的双精度格式。&lt;/p&gt;
&lt;p&gt;IEEE表示的浮点数格式为:
$$
(-1)^s * M * 2^E
$$
对于单精度的表示法这三个部分一共32位，也就是4字节. s占1位；M占23位；E占8位。在双精度浮点格式中这三部分一共占64位。s占1位；M占52位；E占11位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号s决定了这个数是负数(s=1)还是正数(s=0),对于数值0的符号位解释做特殊处理。&lt;/li&gt;
&lt;li&gt;尾数M是一个二进制小数位数，只存储23位。&lt;/li&gt;
&lt;li&gt;阶码E 的作用是对浮点数加权,这个权重是2的E次幂. 对于有符号指数，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的表达式所表示的编码值又分为三种情况: &lt;strong&gt;规格化的值&lt;/strong&gt;、&lt;strong&gt;非规格化的值&lt;/strong&gt;、&lt;strong&gt;特殊值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格化的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况表示E的位数值既不全为0,也不全为1. 阶码会被认为一个有符号的数值,其数值要被减去一个2^(k-1)-1的偏置值(bias),对于单精度来说表达式也就改写为如下形式,偏置值得数值范围为(-126~+127).
$$
（-1）^s * 1.f * 2^(e-127)
$$&lt;/p&gt;
&lt;p&gt;对于M来说,我们它的大小可以通过调整E的值来确保M在范围1&amp;lt;=M&amp;lt;2之间。那么我们可以定义尾数M为M=1+f；这是一种轻松获取额外精度位的技巧(既然第一位总是为1，那么我们就不需要显示的表示它)；这种方式也叫做&lt;strong&gt;隐含以1开头的表示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非格化的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当阶码为全0时，所表示的数就是非格式化形式，此时阶码值为E=1-bias(偏置值).而尾数M的数值也就等于f. 此种格式是有两种情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e=0 且f=0. 则该数为0.这种情况下32位都设置为0. 符号位s可以表示0或1。&lt;/li&gt;
&lt;li&gt;e=0 且f!=0.  该数也是合法的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特殊值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当阶码全为1时，所表示的数是一个特殊值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e=255 且f=0 这个数表示无穷大或者无穷小,这取决于符号位s的值。&lt;/li&gt;
&lt;li&gt;e=255 且f!=0,该值被解释为“不是一个数”,通常使用&lt;strong&gt;NaN&lt;/strong&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个8格式浮点数，其中e为4位，f为3位的浮点数表示如下: (偏置值为: 7)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./image/floatformat.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;回到我们最开头，为什么我们用 0.3 + 0.6 不能得到 0.9 呢？这是因为，浮点数没有办法精确表示 0.3、0.6 和 0.9。事实上，我们拿出 0.1～0.9 这 9 个数，其中只有 0.5 能够被精确地表示成二进制的浮点数，也就是 s = 0、e = -1、f = 0 这样的情况。&lt;/p&gt;
&lt;h2 id=&#34;三数字运算&#34;&gt;三、数字运算&lt;/h2&gt;
&lt;p&gt;以上，我们介绍了如何用二进制表示一个十进制的正数、负数、浮点数。可以发现，采用不同的编码方式所表示的数范围不同。介绍完了数字如何用二进制表示，我们来看看如果使用二进制做我们常见的算术运算。&lt;/p&gt;
&lt;p&gt;注： 在里没有特殊表示的情况下都采用4位二进制数来运算。&lt;/p&gt;
&lt;h4 id=&#34;无符号数加法&#34;&gt;无符号数加法&lt;/h4&gt;
&lt;p&gt;对于一个4位的无符号数，我们可以表示的数字范围是0~15. 如果我们取两个数x=11,y=14;那么这两个数字的和(25)并不能被4位的数字范围所表示. 而需要5位来表示，这也就产我们常说的产生了溢出.&lt;/p&gt;
&lt;p&gt;对于一个w位的数字来说，两个数相加,我们可以得到如下结论:
$$
x+y=\begin{cases}
x+y,\quad &amp;amp;x+y\lt 2^w  &amp;amp; 正常\\&lt;br&gt;
x+y-2^w,\quad &amp;amp;2^w&amp;gt;x+y&amp;lt;2^(w+1)  &amp;amp; 溢出
\end{cases}
$$
对于x+y，如果两个数的和小于2^w所表示的最大的数时,其结果表示x+y本身，但是如果大于，就需要舍弃最高位，也就相当于从和中减去了2^w.&lt;/p&gt;
&lt;h4 id=&#34;补码加法&#34;&gt;补码加法&lt;/h4&gt;
&lt;p&gt;对于补码的加法运算来说会产生三种情况,&lt;code&gt;结果太小&lt;/code&gt;、&lt;code&gt;正常&lt;/code&gt;、&lt;code&gt;结果太大&lt;/code&gt;. 三种情况如下:
$$
x+y=\begin{cases}
x+y-2^w,\quad &amp;amp;x+y \ge 2^(w-1)  &amp;amp; 正溢出\\&lt;br&gt;
x+y,\quad &amp;amp;-2^(w-1) \ge x+y &amp;lt; 2^(w-1)  &amp;amp; 正常\\&lt;br&gt;
x+y+2^w,\quad &amp;amp; x+y&amp;lt;-2^(w+1)  &amp;amp;  负溢出
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;对于补码来说，两个数x+y的取值范围为&lt;code&gt;-2^w&lt;/code&gt;~ &lt;code&gt;2^w-2&lt;/code&gt;, 当和大于最大值时，我们说发生了正溢出，此时我们要减去最大值；当和小于最小值时，我们说发生了负溢出，此时要加上最大值。&lt;/p&gt;
&lt;h4 id=&#34;无符号乘法&#34;&gt;无符号乘法&lt;/h4&gt;
&lt;p&gt;两个无符号数的乘法产生的数值大小范围为0~(2^w-1)^2. 所表示的数可能需要2w为来表示. 但实际中我们一般只表示低w位代表的值.
$$
x * y = (x *y)mod2^w
$$&lt;/p&gt;
&lt;h4 id=&#34;补码乘法&#34;&gt;补码乘法&lt;/h4&gt;
&lt;p&gt;两个有符号数的乘法取值范围为-2^(w-1) * (2^(w-1)-1) ~ (-2(w-1)) * (-2(w-1)).以一个四位为列，乘积所表示的范围为-56~86. 这个数也需要2w位.长我们也是将得到的数截断w位来实现的.这相当于将该值模上2^w,在将无符号数转换为补码.
$$
x * y = U2T((x *y)mod2^w)
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;U2T是一个将无符号数转换为补码的一个函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;移位&#34;&gt;移位&lt;/h4&gt;
&lt;p&gt;不管是无符号数还是有符号数都可以通过移位来实现一个乘或者除一个2的k次幂的数.这在C语言中也叫做左移和右移操作,例如对于4位的数值11(1011),当左移两位时得到数值(101100),这个数所表示的无符号十进制也是44,将其截断后得到的数值便是1100(数值为12=44 mod 16).&lt;/p&gt;
&lt;p&gt;在大多数机器上,整数的乘法指令相当慢,需要10个或者更多时钟周期,而对于其他整数运算(加法、移位)等只需要1个时钟周期,为此，编译器会使用一项重要的优化功能，C语言编译器会试图使用移位、加法、减法等组合来消除很多整数乘以常数的情况。如x * 14, 编译器会将重写为(x&amp;laquo;3) + (x &amp;laquo;2) + (x &amp;laquo;1),将一个乘法替换为三个移位和两个加法。&lt;/p&gt;
&lt;h2 id=&#34;四总结&#34;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;以上就是我们如何在计算机里面去表示一个有符号数、无符号数、浮点数，以及我们如何使用他们做常见的加减乘除运算。在实际中乘法、除法都是多指令周期的运算，在底层编译器中会使用移位、加法等组合来优化这样的指令计算。&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
