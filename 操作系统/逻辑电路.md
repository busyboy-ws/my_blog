与计算机相关的底层硬件

[TOC]

## 一、逻辑电路

在数字逻辑电路中，电平的高低有两种状态，我们称之为**高电平**、**低电平**。一般规定低电平为0~0.25V,高电平为3.5-5V. 在TTL门电路中，把低电平用数字0表示，把高电平用数字1表示。

![dianlu](./image/dianlu.jpg)

由此可以看出，高低电频的表示和二进制数字的表示法一样，那么我们就可以使用组合的逻辑电路来实现二进制之间的逻辑计算。

## 二、门电路

在数字电路中，所谓的“门”就是只能实现基本逻辑关系的电路。二进制最基本的逻辑关系是**与**、**或**、**非**;对应于电路中来说的逻辑门就是**与门**、**或**、**非门**.逻辑门可以用电阻、电容、二极管、三极管等分立元件组成。也可以将门电路的所有器件以及连接导线制作在同一块半导体基片上、构成**集成逻辑门电路**。

> 这里我们不讨论基本的`电阻`，`三极管`等基本元件，详细讨论下三个逻辑门的实现。

#### 与门

在数字逻辑中逻辑与表示从输入到输出的**与**逻辑运算,我们来看一个真值表:

| 输入 |      | 输出    |
| ---- | ---- | ------- |
| A    | B    | A AND B |
| 0    | 0    | 0       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 1       |

当且仅当两个输入的数都为TRUE时,输出才为TRUE;对应逻辑门电路，仅当输入均为高电平(1)时，输出才为高电平。

对应的逻辑电路图表示如下:

![and](./image/and.jpg)

#### 或门

在数字逻辑中逻辑与表示从输入到输出的**或**逻辑运算,我们来看一个真值表:

| 输入 |      | 输出   |
| ---- | ---- | ------ |
| A    | B    | A OR B |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

只要输入的两个数有一个为TRUE时，输出就为TRUE.对应于逻辑电路,只要两个输出中有一个为高电平,则输出为高电平。

![and](./image/or.jpg)

#### 非门

非门也称之为反相器，在数字逻辑中表示从输入到输出的取反操作. 真值表如下:

| 输入 A | 输出 NOT |
| ------ | -------- |
| 0      | 1        |
| 1      | 0        |

对应于电路中表示输入高电平则输出低电平。

![and](./image/not.jpg)

## 三、组合逻辑电路

上面讲述了最基本的三种组合逻辑电路，我们知道两个数的逻辑运算除了`与`、`或`、`非`还有`异或`、`或非`等等。他们也有对应的组合逻辑门.如下:

![and](./image/all.jpg)

这些基本的门电路就是我们计算机硬件端的最基本的“积木”. 就像堆积木一样，我们现在包含十几亿级别的晶体管CPU也是由这样一个一个门电路组合而成的。

在描述组合逻辑电路前，我们先看一个异或门和与非门是如何构造的。

**与非门**

与非门的输出结果恰好和与门的结果刚好相反，我们看一下它的真值表:

| 输入 |      | 输出 |
| ---- | ---- | ---- |
| A    | B    | NAND |
| 0    | 0    | 1    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

**异或门**

我们知道异或是输入相同时为0，输入不同时为1.真值表如下:

| 输入 |      | 输出 |
| ---- | ---- | ---- |
| A    | B    | XOR  |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

首先，我们直观上可以看到，或门的输出和我们想要的一样。除了最后一个。与非门的输出也和我们想要的一样除了第一个。所以如果将这两个门的输出在做一次与运算也就得到了我们想要的结果。这便是异或门。

![and](./image/异或门.jpg)

#### 半加器

半加器的功能是将两个一位二进制数相加,它有两个输出:

* 和: 表示这个数的相加之和,用符号`S`表示
* 进位: 只有两个数为1时才会产生进位。用符号`C`表示。

半加器的真值表如下:

| 输入 |      | 输出 |      |
| ---- | ---- | ---- | ---- |
| A    | B    | C    | S    |
| 0    | 0    | 0    | 0    |
| 0    | 1    | 0    | 1    |
| 1    | 0    | 0    | 1    |
| 1    | 1    | 1    | 0    |

一个最简单的半加器被设计为使用**异或门**来产生S,一个**与门**来产生C.

* 异或门: 相同则为0，不同则为1. 1+1 =》 0 ， 0+0 =》0
* 与门: 当输入同时为1时，输出为1.这就可以表示有进位。

一个半加器的示意图如下:

![and](./image/half_add.jpg)

#### 全加器

从半加器可以看出，如果计算两个1位的二进制数字是没有问题的，但是如果一个二进制数有2位、3位就不行了。不能计算的原因也很简单,它只能接受两个输入的数、却无法接受进位数。所以就有一个全加器的元件来解决这个问题了。

全加器将两个一位二进制数相加，并根据接收到的低位进位信号，输出和、进位输出.全加器的三个输入信号为两个加数A、B以及进位数C. 来看一看真值表:

| 输入 |      |           | 输出      |      |
| ---- | ---- | --------- | --------- | ---- |
| A    | B    | C (input) | C(output) | S    |
| 0    | 0    | 0         | 0         | 0    |
| 1    | 0    | 0         | 0         | 1    |
| 1    | 0    | 1         | 1         | 0    |
| 1    | 0    | 0         | 0         | 1    |
| 0    | 1    | 1         | 1         | 0    |

全加器的输出和半加器类似，包括高位的进位信号C和本位的和信号S。

全加器的设计也很简单，实际上可以使用两个半加器加上一个或门即可组合成一个全加器。

**第一个半加器和个位的加法一样，得到是否进位X和对应的两个数加完后的结果Y.然后把这个Y和个位的进位信息U在连接到另一个半加器中，就会得到一个是否进位的信号V和对应的加法后的结果W. 这个W便是我们在第二位上留下的结果。 但对于第二位来说也需要判断是否进位，这时只需要将进位信号V和进位信号X进行与运算，便知道是否需要向前进位。**

这样，通过两个半加器和或门，我们就得到一个能够接受进位信号、加数、被加数，这样三个数组成的加法。全加器计算过程如下:

![and](./image/全加器.jpg)

既然有了全加器可以来表示某个位置的加法，那么对于有8位的二进制数我们只需要连接8个就行了。这样也就可以表示8位二进制数相加，也就是一个加法器。不过你可能会发现对于加法后的和的两侧是需要特殊考虑一下。

* 个位来说我们不需要一个全加器，半加器就可以完成工作，当然我们也可以将个位的全加器进位输入始终为0.
* 最左侧的如果有进位信号就无法保存了，因为它已经超出了当前加法器的个数。

在C语言中，部分情况下我们计算两个整数相加会得到一个负数,此时你应该知道了为什么了，因为这个加法的结果溢出了。

加法器有很多种设计方式，可以参考维基百科的设计.[加法器](<https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8>)

## 四、减法

